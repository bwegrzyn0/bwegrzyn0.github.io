<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-07-06T16:37:14+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">bwegrzyn0.github.io</title><subtitle>Fizyka i programowanie</subtitle><entry><title type="html">Tworzenie prostej symulacji grawitacji w C++, część 1: SDL2</title><link href="http://localhost:4000/programowanie/tworzenie%20prostej%20symulacji%20grawitacji%20w%20c++/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-1-sdl2" rel="alternate" type="text/html" title="Tworzenie prostej symulacji grawitacji w C++, część 1: SDL2" /><published>2025-07-06T00:00:00+02:00</published><updated>2025-07-06T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/tworzenie%20prostej%20symulacji%20grawitacji%20w%20c++/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-1-sdl2</id><content type="html" xml:base="http://localhost:4000/programowanie/tworzenie%20prostej%20symulacji%20grawitacji%20w%20c++/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-1-sdl2"><![CDATA[<h2 id="cel-projektu">Cel projektu</h2>
<p>Celem tego projektu jest stworzenie programu w C++, który będzie pozwalał użytkownikowi:</p>
<ul>
  <li>dodawać do sceny ciała niebieskie, które będą oddziaływać ze sobą grawitacyjnie</li>
  <li>modyfikować ich parametry, takie jak masa, prędkość, położenie, jasność itd. za pomocą prostego interfejsu</li>
  <li>pauzować, przyspieszać, cofać, resetować symulację</li>
  <li>poruszać się kamerą po scenie za pomocą myszki, przybliżać i oddalać widok</li>
  <li>wykreślać i przewidywać trajektorie obiektów</li>
  <li>ustalać punkt odniesienia dla trajektorii</li>
  <li>zablokować widok na jednym obiekcie.</li>
</ul>

<p>Program ma spełniać również następujące założenia:</p>
<ul>
  <li>ruch planet ma być dokładnie obliczany za pomocą algorytmu Rungego-Kutty (opisanego w <a href="/programowanie/numeryczne-rozwiązywanie-równań-różniczkowych-2-rzędu-metodą-rungego-kutty" target="_blank">tym</a> artykule)</li>
  <li>program ma być zoptymalizowany</li>
  <li>ruch będzie odbywał się w jednej płaszczyźnie i przedstawiany będzie widok z góry</li>
  <li>oświetlenie planet, zaćmienia (gdy jedna planeta przechodzi za drugą)</li>
  <li>planety będą przedstawiane jako koła o różnych kolorach</li>
  <li>anti-aliasing planet</li>
  <li>zarządzanie obiektami w kodzie powinno być łatwe i uporządkowane.</li>
</ul>

<h2 id="kod-źródłowy">Kod źródłowy</h2>
<p>Kod źródłowy projektu jest dostępny w <a href="https://github.com/bwegrzyn0/grav-sim" target="_blank">repozytorium GitHub</a>.</p>

<h2 id="wyświetlanie-okna---sdl2">Wyświetlanie okna - SDL2</h2>
<p>Do wyświetlania okna i rysowania na nim w tym projekcie użyłem bibliotekę <a href="https://www.libsdl.org/" target="_blank">SDL2</a>. Dobry poradnik, jak ją używać, można znaleźć <a href="https://lazyfoo.net/tutorials/SDL/index.php" target="_blank">tutaj</a>.</p>

<h3 id="inicjalizacja-sdl">Inicjalizacja SDL</h3>
<p>W pliku <code class="language-plaintext highlighter-rouge">main.cpp</code> dodałem bibliotekę SDL2:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;SDL/SDL2.h&gt;</span><span class="cp">
</span></code></pre></div></div>
<p>a następnie utworzyłem zmienne i obiekty:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// wymiary okna</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>

<span class="c1">// okno</span>
<span class="n">SDL_Window</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="c1">// renderer</span>
<span class="n">SDL_Renderer</span><span class="o">*</span> <span class="n">renderer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>
<p>Obiekt <code class="language-plaintext highlighter-rouge">renderer</code> będzie odpowiedzialny za rysowanie pikseli w oknie <code class="language-plaintext highlighter-rouge">window</code>. Stworzyłem funkcję inicjalizującą SDL:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja odpowiadająca za inicjalizację SDL</span>
<span class="kt">bool</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="c1">// inicjalizuj SDL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Could not init SDL: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
		<span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// utwórz okno</span>
		<span class="n">window</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span><span class="s">"grav-sim"</span><span class="p">,</span> <span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span> <span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">SDL_WINDOW_SHOWN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"Could not create window: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
			<span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// stwórz renderer</span>
			<span class="n">renderer</span> <span class="o">=</span> <span class="n">SDL_CreateRenderer</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">SDL_RENDERER_ACCELERATED</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">renderer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"Could not create renderer: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
				<span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Jeśli inicjalizacja nie przebiegnie pomyślnie, funkcja zwróci <code class="language-plaintext highlighter-rouge">false</code>. Potrzebna jest również funkcja “sprzątająca” po wszystkim:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja odpowiadająca za "posprzątanie" po wszystkim</span>
<span class="kt">void</span> <span class="nf">close</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// zniszcz okno, zwolnij miejsce w pamięci, zamknij SDL</span>
	<span class="n">SDL_DestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
	<span class="n">window</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">SDL_Quit</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="rejestrowanie-wejścia-od-użytkownika">Rejestrowanie wejścia od użytkownika</h3>
<p>W tym celu utworzyłem obiekt <code class="language-plaintext highlighter-rouge">SDL_Event</code>, który będzie wykrywał zdarzenia, takie jak wciśnięcie klawiatury, myszki itd. oraz funkcję, która na podstawie wykrytego zdarzenia wypisze informację do konsoli:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">SDL_Event</span> <span class="n">event</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">handleEvents</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">SDL_PollEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// funkcja sprawdzająca zdarzenia</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// typ zdarzenia</span>
            <span class="k">case</span> <span class="n">SDL_KEYDOWN</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Key press</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">// wciśnięcie klawisza na klawiaturze</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">SDL_KEYUP</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Key up</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">// puszczenie klawisza na klawiaturze</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">SDL_QUIT</span><span class="p">:</span>
                <span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// zamknięcie okna</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Quitting</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="nl">default:</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Zmienna <code class="language-plaintext highlighter-rouge">running</code> mówi, czy program jest uruchomiony. Przyda się ona w jednym z kolejnych kroków.</p>

<h3 id="rysowanie">Rysowanie</h3>
<p>Utworzyłem funkcję, która będzie odpowiedzialna za rysowanie na ekranie. Dodałem w niej również rysowanie białego prostokąta:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span> <span class="c1">// ustawiamy kolor tła (RGBA)</span>
	<span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span> <span class="c1">// zapełniamy tło</span>

	<span class="n">SDL_Rect</span> <span class="n">rect</span><span class="p">;</span> <span class="c1">// tworzymy nowy obiekt typu prostokąt</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// ustalamy jego położenie i rozmiary</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// ustawiamy kolor prostokąta</span>
	<span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="p">);</span> <span class="c1">// rysujemy wypełniony prostokąt</span>

	<span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span> <span class="c1">// wyświetlamy obraz na ekranie</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pętla-programu">Pętla programu</h3>
<p>Utworzyłem funkcję zawierającą główną pętlę programu:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handleEvents</span><span class="p">();</span>
		<span class="n">draw</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Na razie kod jest uruchamiany w pętli while, czyli jak najszybciej jest to możliwe. Jest to oczywiście nieopłacalne i niestabilne. Zostanie to naprawione później.</p>

<p>Tak wygląda moja funkcja <code class="language-plaintext highlighter-rouge">main()</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">loop</span><span class="p">();</span>
	<span class="n">close</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="co-dalej">Co dalej?</h2>
<p>Powyższy program wyświetla okno, a w nim biały prostokąt na czarnym tle. Kod tego programu w całości dostępny jest w <a href="https://github.com/bwegrzyn0/grav-sim/commit/2265e32b3415e08a4f6f77b149b98d625eea4463" target="_blank">commicie</a> na GitHub. W następnej części opiszę proces rysowania kół i okręgów za pomocą algorytmu midpoint oraz to, jak dodałem planety.</p>]]></content><author><name></name></author><category term="Programowanie" /><category term="Tworzenie prostej symulacji grawitacji w C++" /><summary type="html"><![CDATA[Cel projektu Celem tego projektu jest stworzenie programu w C++, który będzie pozwalał użytkownikowi: dodawać do sceny ciała niebieskie, które będą oddziaływać ze sobą grawitacyjnie modyfikować ich parametry, takie jak masa, prędkość, położenie, jasność itd. za pomocą prostego interfejsu pauzować, przyspieszać, cofać, resetować symulację poruszać się kamerą po scenie za pomocą myszki, przybliżać i oddalać widok wykreślać i przewidywać trajektorie obiektów ustalać punkt odniesienia dla trajektorii zablokować widok na jednym obiekcie.]]></summary></entry><entry><title type="html">Numeryczne rozwiązywanie równań różniczkowych 2 rzędu metodą Rungego-Kutty</title><link href="http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty" rel="alternate" type="text/html" title="Numeryczne rozwiązywanie równań różniczkowych 2 rzędu metodą Rungego-Kutty" /><published>2025-06-30T00:00:00+02:00</published><updated>2025-06-30T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty</id><content type="html" xml:base="http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty"><![CDATA[<h2 id="metoda-rungego-kutty">Metoda Rungego-Kutty</h2>
<p>Mamy dane równanie różniczkowe 1 rzędu w postaci
$$ \frac{dy}{dx}=f(x,y). $$
Najprostszą metodą, aby rozwiązać tego typu równanie numerycznie jest metoda Eulera. Pochodną możemy przybliżyć jako
$$ \frac{dy}{dx}\approx\frac{y(x+\Delta x)-y(x)}{\Delta x}, $$
a stąd
$$ y(x+\Delta x)\approx y(x)+\Delta x f(x,y). $$
Metoda ta jest bardzo niedokładna szczególnie dla rozwiązań oscylujących. Jest ona również nazywana metodą Rungego-Kutty 1 rzędu.</p>

<p>O wiele lepsze przybliżenie daje metoda Rungego-Kutty 4 rzędu. W pierwszej kolejności należy obliczyć 4 wielkości:
$$ k_1=f(x,y) $$
$$ k_2=f(x+\frac{\Delta x}{2}, y+\frac{\Delta x}{2}k_1) $$
$$ k_3=f(x+\frac{\Delta x}{2}, y+\frac{\Delta x}{2}k_2) $$
$$ k_4=f(x+\Delta x, y+\Delta x\,k_3), $$
a następnie możemy obliczyć wartość szukanej funkcji w kolejnym kroku:
$$ y(x+\Delta x)\approx y(x)+\frac{\Delta x}{6}(k_1+2k_2+2k_3+k_4). $$</p>
<h3 id="przykład">Przykład</h3>
<p>Rozważmy równanie nieliniowe
$$ \frac{dy}{dx}=y\cos x$$
z warunkiem początkowym $ y(0)=1 $. Łatwo jest sprawdzić, że jego rozwiązaniem jest $ y=e^{\sin x}$.</p>

<p>Program rozwiązujący to równanie numerycznie został napisany w C++.</p>

<p>W pierwszej kolejności definiujemy zmienne i warunki początkowe:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// ustawiamy y na wartość początkową</span>
<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// ustawiamy x na wartość początkową</span>
<span class="kt">float</span> <span class="n">x_max</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> <span class="c1">// końcowa wartość x</span>
<span class="kt">float</span> <span class="n">step</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// krok - Delta x</span>
</code></pre></div></div>

<p>Następnie zdefiniujmy naszą funkcję $f(x,y)$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">dy_dx</span><span class="p">(</span><span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Teraz musimy wykonać <code class="language-plaintext highlighter-rouge">(x_max-x_min)/step</code> kroków, a w każdym z nich wykonać procedurę opisaną na początku artykułu:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">float</span> <span class="n">k_1</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_2</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">k_1</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_3</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_4</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">*</span><span class="n">k_3</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="p">);</span>

		<span class="n">x</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span> <span class="c1">// zwiększamy x o jeden krok</span>
		<span class="n">y</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3</span><span class="o">+</span><span class="n">k_4</span><span class="p">);</span> <span class="c1">// obliczamy y(x+Delta x)</span>
		<span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// zapisujemy wynik do pliku </span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wyniki zapisałem do pliku <code class="language-plaintext highlighter-rouge">.csv</code>, a następnie naniosłem w pythonie na widoczny poniżej wykres:</p>

<p align="center">
<img src="/assets/images/2025-06-30/przyklad1.svg" width="500" />
</p>
<p>Czerwona linia przedstawia rozwiązanie analityczne, a niebieskie krzyżyki rozwiązanie numeryczne. Widzimy, że metoda Rungego-Kutty 4 rzędu nawet przy dużych wartościach $ \Delta x $ daje bardzo dobre rezultaty.</p>

<h2 id="równanie-różniczkowe-2-rzędu-jako-układ-równań-1-rzędu">Równanie różniczkowe 2 rzędu jako układ równań 1 rzędu</h2>
<p>Niech będzie dane równanie różniczkowe 2 rzędu:
$$ \frac{d^2 y}{dx^2}=f(x, y, y’). $$
Podstawienie $ u=y’ $ daje nam układ równań pierwszego rzędu
$$
\begin{cases} u=y’ \\ u’ = f(x, y, u)  \end{cases} 
$$</p>

<h3 id="przykład-1">Przykład</h3>
<p>Rozważmy równanie ruchu tłumionego oscylatora harmonicznego:
$$ \ddot{x}+2\beta m\dot{x}+\omega_0^2 x = 0. $$
Podstawienie $v=\dot{x}$ daje nam układ równań
$$
\begin{cases} v=\dot{x} \\ \dot{v}=-2\beta v-\omega_0^2 x \end{cases}
$$</p>

<h2 id="numeryczne-rozwiązywanie-równań-2-rzędu">Numeryczne rozwiązywanie równań 2 rzędu</h2>
<p>Aby numerycznie rozwiązać równanie 2 rzędu musimy mieć dane $y(x_0)$ oraz $u(x_0)$, gdzie $x_0$ to pewna wartość początkowa zmiennej.</p>

<p>W pierwszej kolejności obliczamy $k_1$ dla obydwu równań:
$$ k_{1y}=g(x, y, u), $$
gdzie $g(x, y, u)=u$.
$$ k_{1u}=f(x, y, u) $$
Aby obliczyć $k_{2y}$, za $u$ podstawiamy $u+k_{1u}\Delta x/2$:
$$ k_{2y}=g(x+\frac{\Delta x}{2}, y+k_{1y}\frac{\Delta x}{2}, u+k_{1u}\frac{\Delta x}{2}) $$
i podobnie obliczamy $k_{2u}$:
$$ k_{2u}=f(x+\frac{\Delta x}{2}, y+k_{1y}\frac{\Delta x}{2}, u+k_{1u}\frac{\Delta x}{2}a). $$
Prodecura wygląda analogicznie dla $k_3$ i $k_4$. Finalnie możemy obliczyć $y(x+\Delta x)$:
$$ y(x+\Delta x)=y(x)+\frac{\Delta x}{6}(k_{1y}+2k_{2y}+2k_{3y}+k_{4y}) $$
i analogicznie $u$.</p>

<h3 id="przykład-2">Przykład</h3>
<p>Rozważmy wcześniejsze równanie ruchu tłumionego oscylatora harmonicznego z warunkami początkowymi $x(0)=0$ i $v(0)=1$ oraz parametrami $\omega_0=2$, $\beta=0.5$, $m=1$.</p>

<p>Zdefiniujmy zmienne i warunki początkowe:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// warunki początkowe</span>
<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t_max</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// jak daleko ma sięgać symulacja</span>
<span class="kt">float</span> <span class="n">step</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span> <span class="c1">// Delta x</span>
<span class="c1">// parametry układu</span>
<span class="kt">float</span> <span class="n">omega_0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</code></pre></div></div>
<p>Następnie zdefiniujmy funkcje $f(x)$ i $g(x)$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja obliczająca dv/dt</span>
<span class="kt">float</span> <span class="nf">f</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">v</span><span class="o">-</span><span class="n">omega_0</span><span class="o">*</span><span class="n">omega_0</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// funkcja obliczająca dx/dt</span>
<span class="kt">float</span> <span class="nf">g</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Utwórzmy funkcję, która oblicza kolejne wartości $x$ i $v$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja obliczająca następną wartość x  z użyciem metody Rungego-Kutty</span>
<span class="kt">void</span> <span class="nf">next</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// obliczamy wszystkie k dla obu równań</span>
	<span class="kt">float</span> <span class="n">k_1x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_1v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_2x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_1x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_1v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_2v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_1x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_1v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_3x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_2x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_2v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_3v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_2x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_2v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_4x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_3x</span><span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_3v</span><span class="o">*</span><span class="n">step</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_4v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_3x</span><span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_3v</span><span class="o">*</span><span class="n">step</span><span class="p">);</span>
	
	<span class="c1">// obliczamy kolejne wartości dla x oraz v</span>
	<span class="o">::</span><span class="n">x</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3x</span><span class="o">+</span><span class="n">k_4x</span><span class="p">);</span>
	<span class="o">::</span><span class="n">v</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1v</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2v</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3v</span><span class="o">+</span><span class="n">k_4v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Należy pamiętać, aby również obliczać kolejne wartości dla $v$, ponieważ w przeciwnym razie pochodna będzie cały czas stała. Możemy teraz utworzyć pętlę w funkcji <code class="language-plaintext highlighter-rouge">main()</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">t_max</span><span class="o">-</span><span class="n">t_min</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span>
    <span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span>  <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// zapisujemy wyniki do pliku</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Podobnie jak wcześniej wyniki oraz rozwiązanie analityczne naniosłem na jeden wykres, otrzymując idealną zgodność:</p>
<p align="center">
<img src="/assets/images/2025-06-30/przyklad2.svg" width="500" />
</p>

<p>Pełne pliki źródłowe są dostępne do pobrania tutaj: <br />
<a href="/assets/downloads/2025-06-30/przykład1.cpp" target="_blank">przykład1.cpp</a> <br />
<a href="/assets/downloads/2025-06-30/przykład2.cpp" target="_blank">przykład2.cpp</a></p>]]></content><author><name></name></author><category term="Programowanie" /><summary type="html"><![CDATA[Metoda Rungego-Kutty Mamy dane równanie różniczkowe 1 rzędu w postaci $$ \frac{dy}{dx}=f(x,y). $$ Najprostszą metodą, aby rozwiązać tego typu równanie numerycznie jest metoda Eulera. Pochodną możemy przybliżyć jako $$ \frac{dy}{dx}\approx\frac{y(x+\Delta x)-y(x)}{\Delta x}, $$ a stąd $$ y(x+\Delta x)\approx y(x)+\Delta x f(x,y). $$ Metoda ta jest bardzo niedokładna szczególnie dla rozwiązań oscylujących. Jest ona również nazywana metodą Rungego-Kutty 1 rzędu.]]></summary></entry><entry><title type="html">Wyznaczanie gęstości powietrza za pomocą wahadła matematycznego</title><link href="http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego" rel="alternate" type="text/html" title="Wyznaczanie gęstości powietrza za pomocą wahadła matematycznego" /><published>2025-06-18T00:00:00+02:00</published><updated>2025-06-18T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego</id><content type="html" xml:base="http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego"><![CDATA[<h2 id="tłumione-wahadło-matematyczne">Tłumione wahadło matematyczne</h2>
<p>Rozważmy najprostszy model wahadła. Jest to masa punktowa $m$ zawieszona na nieważkiej lince o długości $l$. Na wahadło działa siła ciężkości $\mathbf{Q}$, która rozkłada się na składową radialną i styczną do linki oraz siła reakcji linki $\mathbf{F_r}$, która równoważy $\mathbf{Q_r}$. Na masę działa również siła oporu $\mathbf{F_o}$. Poniżej został przedstawiony schemat tego układu.</p>

<p align="center">
<img src="/assets/images/2025-06-18/wahadlotlumione.svg" width="500" />
</p>

<p>Przy małych prędkościach wartość siły oporu $\mathbf{F_o}$  działającej na naszą masę jest wprost proporcjonalna do prędkości tego ciała. Dlatego założymy, że nasze wahadło porusza się z niewielką prędkością. Pozwoli nam to zapisać 2 zasadę dynamiki jako
$$ \mathbf{M}=\mathbf{l}\times\mathbf{Q_s}+\mathbf{l}\times\mathbf{F_o}, $$
gdzie $\mathbf{l}$ to wektor łączący punkt zaczepienia wahadła i masę $m$.</p>

<p>Niech $\hat{\mathbf{n}}$ będzie wektorem jednostkowym leżącym na tym samym kierunku co $\mathbf{Q_s}$ i o zwrocie w lewo. Wtedy $\mathbf{Q_s}=Q_s\hat{\mathbf{n}}$. Wiadomo, że $Q_s=Q\sin\theta=mg\sin\theta$, czyli $\mathbf{Q_s}=mg\sin\theta\,\hat{\mathbf{n}}$. Wtedy $\mathbf{l}\times\mathbf{Q_s}=mg\sin\theta\,\mathbf{l}\times\hat{\mathbf{n}}$. Łatwo zauważyć, że $\mathbf{l}\times\hat{\mathbf{n}}=-l\hat{\mathbf{k}}$, przy czym oś $z$ jest skierowana od ekranu. Zatem $\mathbf{l}\times\mathbf{Q_s}=-mgl\sin\theta\,\hat{\mathbf{k}}$.</p>

<p>Jak wspomniano wcześniej, $\mathbf{F_o}=-2\beta m\mathbf{v}$, gdzie $\beta$ to pewna stała - współczynnik tłumienia, a czynnik $2m$ ułatwi późniejsze obliczenia. Wiemy, że $\mathbf{v}=\boldsymbol{\dot{\theta}}\times\mathbf{l}$, a $\boldsymbol{\dot{\theta}}=\dot{\theta}\hat{\mathbf{k}}$. Na podstawie reguły prawej ręki możemy stwierdzić, że $\mathbf{v}=-\dot{\theta}l\hat{\mathbf{n}}$, a co za tym idzie $\mathbf{F_o}=2\beta ml\dot{\theta}\,\hat{\mathbf{n}}$. Teraz możemy obliczyć moment siły oporów:
$$ \mathbf{l}\times\mathbf{F_o}=2\beta ml\dot{\theta}\,{\mathbf{l}}\times\hat{\mathbf{n}}=-2\beta ml^2\dot{\theta}\,\hat{\mathbf{k}}.$$</p>

<p>Wiemy również, że $\mathbf{M}=I\ddot{\theta}\hat{\mathbf{k}}$, gdzie $I$ to moment bezwładności wahadła wokół punktu zaczepienia. Dla masy punktowej będzie to $ml^2$. Możemy teraz zapisać 2 zasadę dynamiki jako
$$ ml^2\ddot{\theta}\hat{\mathbf{k}}=-mgl\sin{\theta}\,\hat{\mathbf{k}}-2\beta ml^2\dot{\theta}\,\hat{\mathbf{k}}, $$
a po podzieleniu przez $ml^2\hat{\mathbf{k}}$ otrzymamy
$$ \ddot{\theta}+2\beta\dot{\theta}+\frac{g}{l}\sin{\theta}=0. $$
Gdy $\theta$ jest małym kątem, zachodzi w przybliżeniu równość $\sin\theta\approx\theta$, co pozwala nam zapisać 
$$ \ddot{\theta}+2\beta\dot{\theta}+\omega_0^2\theta=0, $$
gdzie $\omega_0=\sqrt{g/l}$.</p>

<p>Równanie charakterystyczne to
$$ r^2+2\beta r+\omega_0^2=0, $$
a jego rozwiązania to
$$ r=-\beta\pm i\omega, $$
gdzie $\omega=\sqrt{\omega_0^2-\beta^2}$. Rozwiązanie ogólne to wtedy
$$ \theta=e^{-\beta t}\left(Ae^{i\omega}+Be^{-i\omega}\right), $$
gdzie $A$ i $B$ to pewne stałe. Zapis ten jest równoważny
$$ \theta=e^{-\beta t}\left[(A+B)\cos\omega t+(A-B)i\sin\omega t\right]. $$
$\theta$ musi być liczbą rzeczywistą, dlatego $B=\overline{A}$. Niech $A=a+bi$, wtedy $B=a-bi$. Wstawiając to do powyższego równania otrzymamy
$$ \theta=e^{-\beta t}\left(2a\cos\omega t-2b\sin\omega t\right). $$
Ponieważ w nawiasie znajduje się liniowa kombinacja sinusa i cosinusa, możemy zapisać
$$ \theta=\theta_0 e^{-\beta t}\cos(\omega t+\varphi), $$
gdzie $\theta_0$ to amplituda drgań, a $\varphi$ to faza.</p>

<h2 id="pomiar-współczynnika-tłumienia">Pomiar współczynnika tłumienia</h2>
<p>Skonstruowano wahadło z cienkiej, w przybliżeniu nieważkiej nitki oraz śruby zamocowanej na jej końcu. Ponieważ rozmiary śruby były znacznie mniejsze niż długość wahadła, cała masa była w przybliżeniu skoncentrowana w jednym punkcie. Nitka została owinięta wokół cienkiego patyczka służącego jako punkt zaczepienia. Taki sposób zaczepienia linki umożliwił łatwą regulację długości wahadła. Zakładamy, że współczynnik tłumienia jest na tyle mały, że $\omega\approx\omega_0$.</p>

<p>Mierząc wartość $\theta$, gdy $\cos(\omega t+\varphi)=1$ (gdy wahadło jest w swoim maksymalnym wychyleniu) możemy wyznaczyć $\beta$. Czas mierzymy od chwili puszczenia wahadła, więc $\varphi=0$. Warunek zachodzi w bardzo dobrym przybliżeniu dla małych wychyleń (ponieważ $T$ tak naprawdę zależy od amplitudy), gdy $t=nT$, gdzie $T$ to okres wahadła, a $n=0,1,2,\dots$.
$$		\theta(nT)=\theta_0 e^{-\beta nT} $$
$$		\ln{\theta(nT)}=\ln{\theta_0}+-\beta nT $$
Sporządzając wykres $\ln{\theta(nT)}$ możemy wyznaczyć $\beta$ nawet bez znajomości $\theta_0$, ponieważ będzie to współczynnik kierunkowy prostej najlepszego dopasowania.</p>

<p>Wahadło zostało umieszczone w odległości $d=2$cm od biurka, do którego została przyklejona kartka papieru w kratkę. Aby dokładnie zaznaczać kolejne maksymalne wychylenia wahadła, w odległości $d’&gt;1$m od wahadła zostało umieszczone źródło światła, zgodnie ze schematem.</p>
<p align="center">
<img src="/assets/images/2025-06-18/ukladpom.svg" width="500" />
</p>

<p>Cień rzucany przez linkę różnił się o $\Delta x’$ od prawdziwego jej położenia. Przy wymienionych wcześniej wartościach $d$ i $d’$, $\Delta x’&lt;0.02\Delta x$, zatem błąd jest pomijalny. Błąd związany z wyznaczeniem czasu również został pominięty, ponieważ dla tak małych wychyleń okres był w bardzo dobrym przybliżeniu stały i wahadło służyło jako zegar.</p>

<p>Co 5 okresów na kartce były zaznaczane maksymalne wychylenia wahadła. Następnie została zmierzona odległość linii, na której były zaznaczane kolejne położenia wahadła, od punktu zaczepienia wahadła ($h$), aby wyznaczyć $\tan{\theta}=\Delta x/h$. Ponieważ wychylenia były małe, $\theta\approx\tan{\theta}$. Wyniki pomiarów dla $l=0.8\text{m}$ zostały zestawione na poniższych wykresach.</p>
<p align="center">
<img src="/assets/images/2025-06-18/wykresbeta.svg" width="700" />
</p>

<p>W tym układzie otrzymana wartość $\beta$ to
$$	\beta = 0.01478\pm0.0002\frac{1}{\text{s}} $$
Tak mała niepewność wynika z kilku czynników. Niepewność w pomiarze kąta była bardzo niewielka, ponieważ źródło światła umożliwiało precyzyjne wyznaczenie wychylenia wahadła, a ze względu na dużą odległość $h$ zaznaczanych punktów od osi obrotu, niewielkie zmiany kąta powodowały dużą zmianę w odległości $\Delta x$. Niepewność w pomiarze czasu była pomijalna. Niepewność związana z wzięciem logarytmu naturalnego jest dana w przybliżeniu wzorem
$$	\Delta(\ln x)\approx\frac{\Delta x}{x}. $$
W tym przypadku $\Delta x$ było rzędu $10^{-3}$, a $x$ rzędu $10^{-1}$, czyli niepewność była rzędu $10^{-2}$.</p>

<p>Współczynniki tłumienia wyznaczone dla wielu wahadeł umieściłem na widocznym poniżej wykresie zależności $\beta(l)$. Okazało się, że w dobrym przybliżeniu punkty pomiarowe układają się na prostej o współczynniku kierunkowym $a=(0.0073\pm0.0019)\frac{1}{\text{sm}}$ i wyrazie wolnym $b=(0.0092\pm0.0012)\frac{1}{\text{s}}$. Jak wyjaśnić tę obserwację?</p>
<p align="center">
<img src="/assets/images/2025-06-18/wykresbetal.svg" width="700" />
</p>

<h2 id="wyjaśnienie-zaobserwowanej-zależności">Wyjaśnienie zaobserwowanej zależności</h2>
<p>Można spekulować, że wyraz wolny to część współczynnika tłumienia pochodząca od śruby służącej jako masa na końcu wahadła, a $al$ to wkład pochodzący od nitki.</p>

<p>Prawo Stokesa mówi, że wartość siły działającej na kulę o promieniu $R$ poruszającą się z małą prędkością $v$ w płynie jest dana wzorem
$$	F_o=6\pi\mu R v, $$
gdzie $\mu$ to lepkość dynamiczna. Nitkę można przybliżyć jako złożoną z $l/w$ kul o średnicy $w$, gdzie $w$ to również szerokość nitki, ułożonych jedna za drugą. Promień takiej kuli to wtedy $R=w/2$. Całkowita siła działająca na nitkę to suma sił pochodzących od jej wszystkich małych kul. Każda z nich ma jednak inną prędkość, ponieważ znajduje się w innej odległości od osi obrotu.
$$	F=\sum_{i=0}^{l/w}6\pi\mu\frac{w}{2}v_i=3\pi\mu w\omega\sum_{i=0}^{l/w} r_i, $$
gdzie $r_i$ to odległość $i$-tej kuli od osi obrotu. Aby obliczyć sumę, zapiszmy
$$	\sum_{i=0}^{l/w} r_i=\frac{1}{w}\sum_{i=0}^{l/w} r_i w. $$
Ponieważ $w$ jest małe w porównaniu do $l$, możemy aproksymować sumę jako całkę. Wtedy $w = \Delta r_i$, czyli
$$	\frac{1}{w}\sum_{i=0}^{l/w} r_i w\approx\frac{1}{w}\int_{0}^{l}r\,dr=\frac{l^2}{2w}.$$
Wstawiając ten wynik do wcześniejszego wzoru otrzymujemy
$$	F\approx \frac{3}{2}\pi\mu lv,$$
gdzie $v$ to prędkość końca wahadła. Ponieważ $F=2\beta m v$, zachodzi równość
$$
	\beta=\frac{3\pi\mu}{4m}l,
    $$
co wyjaśnia zaobserwowaną zależność.</p>

<h2 id="wyznaczanie-lepkości-dynamicznej-powietrza">Wyznaczanie lepkości dynamicznej powietrza</h2>
<p>Całkowita siła oporu działająca na wahadło to
$$	F=2\beta mv=2almv+2bmv,$$
gdzie m to masa śrubki zawieszonej na końcu wahadła (masa nitki jest pomijalna). Pierwszy wyraz po prawej stronie to siła pochodząca od nitki, czyli przyrównując to do wcześniej obliczonej siły otrzymujemy
$$		2almv=\frac{3}{2}\pi\mu lv $$
$$		4am=3\pi \mu $$
$$		\mu=\frac{4am}{3\pi}. $$
Zmierzona masa śrubki to $m=(4\pm 0.5)$g oraz $a=(0.0073\pm0.0019)\frac{1}{\text{ms}}$. Przy tych danych
	$$ \mu=(12.4\pm4.8)\times 10^{-6}\text{ Pa s},$$
przy czym tablicowa wartość $\mu$ dla powietrza w temperaturze $293\text{K}$ to $\mu=18.13\times 10^{-6}\text{ Pa s}$.</p>

<h2 id="wyznaczanie-gęstości-powietrza">Wyznaczanie gęstości powietrza</h2>
<p>Kinetyczna teoria gazów daje następujący wzór dla rozrzedzonych gazów:
$$	\mu=\alpha\rho\lambda\sqrt{\frac{2k_B T}{\pi m}},$$
gdzie bezwymiarowy współczynnik $\alpha\approx 1$, $\rho$ to gęstość gazu, $\lambda$ to średnia droga swobodna w tym gazie, $T$ to temperatura, a $m$ to masa cząsteczkowa. Przekształćmy ten wzór do postaci
$$	\rho=\frac{\mu}{\alpha\lambda}\sqrt{\frac{\pi m}{2k_B T}}.$$
Dla powietrza $m\approx29\text{u}\approx 4.28\times 10^{-26}\text{kg}$, $\lambda\approx6,6\times 10^{-8}$m. Temperatura podczas pomiarów wynosiła ok. $T\approx293\text{K}$. Wstawiając te dane do wzoru otrzymujemy wynik 
$$	\rho=(0.77\pm0.30)\frac{\text{kg}}{\text{m}^3},$$
przy czym tablicowa wartość w tej temperaturze to $\rho=1.20\frac{\text{kg}}{\text{m}^3}$. Wynik jest obarczony dużą niepewnością spowodowaną głównie niepewnością $m$ i $\mu$. Należy również zauważyć, że prawdziwa wartość $\rho$ nie mieści się w przedziale niepewności. Jest to najprawdopodobniej spowodowane przybliżeniem nitki jako złożonej z wielu kul.</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Tłumione wahadło matematyczne Rozważmy najprostszy model wahadła. Jest to masa punktowa $m$ zawieszona na nieważkiej lince o długości $l$. Na wahadło działa siła ciężkości $\mathbf{Q}$, która rozkłada się na składową radialną i styczną do linki oraz siła reakcji linki $\mathbf{F_r}$, która równoważy $\mathbf{Q_r}$. Na masę działa również siła oporu $\mathbf{F_o}$. Poniżej został przedstawiony schemat tego układu.]]></summary></entry></feed>