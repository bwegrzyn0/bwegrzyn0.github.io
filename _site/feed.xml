<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-07-05T13:55:30+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">bwegrzyn0.github.io</title><subtitle>Fizyka i programowanie</subtitle><entry><title type="html">Numeryczne rozwiązywanie równań różniczkowych 2 rzędu metodą Rungego-Kutty</title><link href="http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty" rel="alternate" type="text/html" title="Numeryczne rozwiązywanie równań różniczkowych 2 rzędu metodą Rungego-Kutty" /><published>2025-06-30T00:00:00+02:00</published><updated>2025-06-30T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty</id><content type="html" xml:base="http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty"><![CDATA[<h2 id="metoda-rungego-kutty">Metoda Rungego-Kutty</h2>
<p>Mamy dane równanie różniczkowe 1 rzędu w postaci
$$ \frac{dy}{dx}=f(x,y). $$
Najprostszą metodą, aby rozwiązać tego typu równanie numerycznie jest metoda Eulera. Pochodną możemy przybliżyć jako
$$ \frac{dy}{dx}\approx\frac{y(x+\Delta x)-y(x)}{\Delta x}, $$
a stąd
$$ y(x+\Delta x)\approx y(x)+\Delta x f(x,y). $$
Metoda ta jest bardzo niedokładna szczególnie dla rozwiązań oscylujących. Jest ona również nazywana metodą Rungego-Kutty 1 rzędu.</p>

<p>O wiele lepsze przybliżenie daje metoda Rungego-Kutty 4 rzędu. W pierwszej kolejności należy obliczyć 4 wielkości:
$$ k_1=f(x,y) $$
$$ k_2=f(x+\frac{\Delta x}{2}, y+\frac{\Delta x}{2}k_1) $$
$$ k_3=f(x+\frac{\Delta x}{2}, y+\frac{\Delta x}{2}k_2) $$
$$ k_4=f(x+\Delta x, y+\Delta x\,k_3), $$
a następnie możemy obliczyć wartość szukanej funkcji w kolejnym kroku:
$$ y(x+\Delta x)\approx y(x)+\frac{\Delta x}{6}(k_1+2k_2+2k_3+k_4). $$</p>
<h3 id="przykład">Przykład</h3>
<p>Rozważmy równanie nieliniowe
$$ \frac{dy}{dx}=y\cos x$$
z warunkiem początkowym $ y(0)=1 $. Łatwo jest sprawdzić, że jego rozwiązaniem jest $ y=e^{\sin x}$.</p>

<p>Program rozwiązujący to równanie numerycznie został napisany w C++.</p>

<p>W pierwszej kolejności definiujemy zmienne i warunki początkowe:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// ustawiamy y na wartość początkową</span>
<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// ustawiamy x na wartość początkową</span>
<span class="kt">float</span> <span class="n">x_max</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> <span class="c1">// końcowa wartość x</span>
<span class="kt">float</span> <span class="n">step</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// krok - Delta x</span>
</code></pre></div></div>

<p>Następnie zdefiniujmy naszą funkcję $f(x,y)$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">dy_dx</span><span class="p">(</span><span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Teraz musimy wykonać <code class="language-plaintext highlighter-rouge">(x_max-x_min)/step</code> kroków, a w każdym z nich wykonać procedurę opisaną na początku artykułu:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">float</span> <span class="n">k_1</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_2</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">k_1</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_3</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_4</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">*</span><span class="n">k_3</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="p">);</span>

		<span class="n">x</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span> <span class="c1">// zwiększamy x o jeden krok</span>
		<span class="n">y</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3</span><span class="o">+</span><span class="n">k_4</span><span class="p">);</span> <span class="c1">// obliczamy y(x+Delta x)</span>
		<span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// zapisujemy wynik do pliku </span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wyniki zapisałem do pliku <code class="language-plaintext highlighter-rouge">.csv</code>, a następnie naniosłem w pythonie na widoczny poniżej wykres:</p>

<p align="center">
<img src="/assets/images/2025-06-30/przyklad1.svg" width="500" />
</p>
<p>Czerwona linia przedstawia rozwiązanie analityczne, a niebieskie krzyżyki rozwiązanie numeryczne. Widzimy, że metoda Rungego-Kutty 4 rzędu nawet przy dużych wartościach $ \Delta x $ daje bardzo dobre rezultaty.</p>

<h2 id="równanie-różniczkowe-2-rzędu-jako-układ-równań-1-rzędu">Równanie różniczkowe 2 rzędu jako układ równań 1 rzędu</h2>
<p>Niech będzie dane równanie różniczkowe 2 rzędu:
$$ \frac{d^2 y}{dx^2}=f(x, y, y’). $$
Podstawienie $ u=y’ $ daje nam układ równań pierwszego rzędu
$$
\begin{cases} u=y’ \\ u’ = f(x, y, u)  \end{cases} 
$$</p>

<h3 id="przykład-1">Przykład</h3>
<p>Rozważmy równanie ruchu tłumionego oscylatora harmonicznego:
$$ \ddot{x}+2\beta m\dot{x}+\omega_0^2 x = 0. $$
Podstawienie $v=\dot{x}$ daje nam układ równań
$$
\begin{cases} v=\dot{x} \\ \dot{v}=-2\beta v-\omega_0^2 x \end{cases}
$$</p>

<h2 id="numeryczne-rozwiązywanie-równań-2-rzędu">Numeryczne rozwiązywanie równań 2 rzędu</h2>
<p>Aby numerycznie rozwiązać równanie 2 rzędu musimy mieć dane $y(x_0)$ oraz $u(x_0)$, gdzie $x_0$ to pewna wartość początkowa zmiennej.</p>

<p>W pierwszej kolejności obliczamy $k_1$ dla obydwu równań:
$$ k_{1y}=g(x, y, u), $$
gdzie $g(x, y, u)=u$.
$$ k_{1u}=f(x, y, u) $$
Aby obliczyć $k_{2y}$, za $u$ podstawiamy $u+k_{1u}\Delta x/2$:
$$ k_{2y}=g(x+\frac{\Delta x}{2}, y+k_{1y}\frac{\Delta x}{2}, u+k_{1u}\frac{\Delta x}{2}) $$
i podobnie obliczamy $k_{2u}$:
$$ k_{2u}=f(x+\frac{\Delta x}{2}, y+k_{1y}\frac{\Delta x}{2}, u+k_{1u}\frac{\Delta x}{2}a). $$
Prodecura wygląda analogicznie dla $k_3$ i $k_4$. Finalnie możemy obliczyć $y(x+\Delta x)$:
$$ y(x+\Delta x)=y(x)+\frac{\Delta x}{6}(k_{1y}+2k_{2y}+2k_{3y}+k_{4y}) $$
i analogicznie $u$.</p>

<h3 id="przykład-2">Przykład</h3>
<p>Rozważmy wcześniejsze równanie ruchu tłumionego oscylatora harmonicznego z warunkami początkowymi $x(0)=0$ i $v(0)=1$ oraz parametrami $\omega_0=2$, $\beta=0.5$, $m=1$.</p>

<p>Zdefiniujmy zmienne i warunki początkowe:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// warunki początkowe</span>
<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t_max</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// jak daleko ma sięgać symulacja</span>
<span class="kt">float</span> <span class="n">step</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span> <span class="c1">// Delta x</span>
<span class="c1">// parametry układu</span>
<span class="kt">float</span> <span class="n">omega_0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</code></pre></div></div>
<p>Następnie zdefiniujmy funkcje $f(x)$ i $g(x)$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja obliczająca dv/dt</span>
<span class="kt">float</span> <span class="nf">f</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">v</span><span class="o">-</span><span class="n">omega_0</span><span class="o">*</span><span class="n">omega_0</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// funkcja obliczająca dx/dt</span>
<span class="kt">float</span> <span class="nf">g</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Utwórzmy funkcję, która oblicza kolejne wartości $x$ i $v$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja obliczająca następną wartość x  z użyciem metody Rungego-Kutty</span>
<span class="kt">void</span> <span class="nf">next</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// obliczamy wszystkie k dla obu równań</span>
	<span class="kt">float</span> <span class="n">k_1x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_1v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_2x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_1x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_1v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_2v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_1x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_1v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_3x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_2x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_2v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_3v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_2x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_2v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_4x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_3x</span><span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_3v</span><span class="o">*</span><span class="n">step</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_4v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_3x</span><span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_3v</span><span class="o">*</span><span class="n">step</span><span class="p">);</span>
	
	<span class="c1">// obliczamy kolejne wartości dla x oraz v</span>
	<span class="o">::</span><span class="n">x</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3x</span><span class="o">+</span><span class="n">k_4x</span><span class="p">);</span>
	<span class="o">::</span><span class="n">v</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1v</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2v</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3v</span><span class="o">+</span><span class="n">k_4v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Należy pamiętać, aby również obliczać kolejne wartości dla $v$, ponieważ w przeciwnym razie pochodna będzie cały czas stała. Możemy teraz utworzyć pętlę w funkcji <code class="language-plaintext highlighter-rouge">main()</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">t_max</span><span class="o">-</span><span class="n">t_min</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span>
    <span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span>  <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// zapisujemy wyniki do pliku</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Podobnie jak wcześniej wyniki oraz rozwiązanie analityczne naniosłem na jeden wykres, otrzymując idealną zgodność:</p>
<p align="center">
<img src="/assets/images/2025-06-30/przyklad2.svg" width="500" />
</p>

<p>Pełne pliki źródłowe są dostępne do pobrania tutaj: <br />
<a href="/assets/downloads/2025-06-30/przykład1.cpp" target="_blank">przykład1.cpp</a> <br />
<a href="/assets/downloads/2025-06-30/przykład2.cpp" target="_blank">przykład2.cpp</a></p>]]></content><author><name></name></author><category term="Programowanie" /><summary type="html"><![CDATA[Metoda Rungego-Kutty Mamy dane równanie różniczkowe 1 rzędu w postaci $$ \frac{dy}{dx}=f(x,y). $$ Najprostszą metodą, aby rozwiązać tego typu równanie numerycznie jest metoda Eulera. Pochodną możemy przybliżyć jako $$ \frac{dy}{dx}\approx\frac{y(x+\Delta x)-y(x)}{\Delta x}, $$ a stąd $$ y(x+\Delta x)\approx y(x)+\Delta x f(x,y). $$ Metoda ta jest bardzo niedokładna szczególnie dla rozwiązań oscylujących. Jest ona również nazywana metodą Rungego-Kutty 1 rzędu.]]></summary></entry><entry><title type="html">Wyznaczanie gęstości powietrza za pomocą wahadła matematycznego</title><link href="http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego" rel="alternate" type="text/html" title="Wyznaczanie gęstości powietrza za pomocą wahadła matematycznego" /><published>2025-06-18T00:00:00+02:00</published><updated>2025-06-18T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego</id><content type="html" xml:base="http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego"><![CDATA[<h2 id="tłumione-wahadło-matematyczne">Tłumione wahadło matematyczne</h2>
<p>Rozważmy najprostszy model wahadła. Jest to masa punktowa $m$ zawieszona na nieważkiej lince o długości $l$. Na wahadło działa siła ciężkości $\mathbf{Q}$, która rozkłada się na składową radialną i styczną do linki oraz siła reakcji linki $\mathbf{F_r}$, która równoważy $\mathbf{Q_r}$. Na masę działa również siła oporu $\mathbf{F_o}$. Poniżej został przedstawiony schemat tego układu.</p>

<p align="center">
<img src="/assets/images/2025-06-18/wahadlotlumione.svg" width="500" />
</p>

<p>Przy małych prędkościach wartość siły oporu $\mathbf{F_o}$  działającej na naszą masę jest wprost proporcjonalna do prędkości tego ciała. Dlatego założymy, że nasze wahadło porusza się z niewielką prędkością. Pozwoli nam to zapisać 2 zasadę dynamiki jako
$$ \mathbf{M}=\mathbf{l}\times\mathbf{Q_s}+\mathbf{l}\times\mathbf{F_o}, $$
gdzie $\mathbf{l}$ to wektor łączący punkt zaczepienia wahadła i masę $m$.</p>

<p>Niech $\hat{\mathbf{n}}$ będzie wektorem jednostkowym leżącym na tym samym kierunku co $\mathbf{Q_s}$ i o zwrocie w lewo. Wtedy $\mathbf{Q_s}=Q_s\hat{\mathbf{n}}$. Wiadomo, że $Q_s=Q\sin\theta=mg\sin\theta$, czyli $\mathbf{Q_s}=mg\sin\theta\,\hat{\mathbf{n}}$. Wtedy $\mathbf{l}\times\mathbf{Q_s}=mg\sin\theta\,\mathbf{l}\times\hat{\mathbf{n}}$. Łatwo zauważyć, że $\mathbf{l}\times\hat{\mathbf{n}}=-l\hat{\mathbf{k}}$, przy czym oś $z$ jest skierowana od ekranu. Zatem $\mathbf{l}\times\mathbf{Q_s}=-mgl\sin\theta\,\hat{\mathbf{k}}$.</p>

<p>Jak wspomniano wcześniej, $\mathbf{F_o}=-2\beta m\mathbf{v}$, gdzie $\beta$ to pewna stała - współczynnik tłumienia, a czynnik $2m$ ułatwi późniejsze obliczenia. Wiemy, że $\mathbf{v}=\boldsymbol{\dot{\theta}}\times\mathbf{l}$, a $\boldsymbol{\dot{\theta}}=\dot{\theta}\hat{\mathbf{k}}$. Na podstawie reguły prawej ręki możemy stwierdzić, że $\mathbf{v}=-\dot{\theta}l\hat{\mathbf{n}}$, a co za tym idzie $\mathbf{F_o}=2\beta ml\dot{\theta}\,\hat{\mathbf{n}}$. Teraz możemy obliczyć moment siły oporów:
$$ \mathbf{l}\times\mathbf{F_o}=2\beta ml\dot{\theta}\,{\mathbf{l}}\times\hat{\mathbf{n}}=-2\beta ml^2\dot{\theta}\,\hat{\mathbf{k}}.$$</p>

<p>Wiemy również, że $\mathbf{M}=I\ddot{\theta}\hat{\mathbf{k}}$, gdzie $I$ to moment bezwładności wahadła wokół punktu zaczepienia. Dla masy punktowej będzie to $ml^2$. Możemy teraz zapisać 2 zasadę dynamiki jako
$$ ml^2\ddot{\theta}\hat{\mathbf{k}}=-mgl\sin{\theta}\,\hat{\mathbf{k}}-2\beta ml^2\dot{\theta}\,\hat{\mathbf{k}}, $$
a po podzieleniu przez $ml^2\hat{\mathbf{k}}$ otrzymamy
$$ \ddot{\theta}+2\beta\dot{\theta}+\frac{g}{l}\sin{\theta}=0. $$
Gdy $\theta$ jest małym kątem, zachodzi w przybliżeniu równość $\sin\theta\approx\theta$, co pozwala nam zapisać 
$$ \ddot{\theta}+2\beta\dot{\theta}+\omega_0^2\theta=0, $$
gdzie $\omega_0=\sqrt{g/l}$.</p>

<p>Równanie charakterystyczne to
$$ r^2+2\beta r+\omega_0^2=0, $$
a jego rozwiązania to
$$ r=-\beta\pm i\omega, $$
gdzie $\omega=\sqrt{\omega_0^2-\beta^2}$. Rozwiązanie ogólne to wtedy
$$ \theta=e^{-\beta t}\left(Ae^{i\omega}+Be^{-i\omega}\right), $$
gdzie $A$ i $B$ to pewne stałe. Zapis ten jest równoważny
$$ \theta=e^{-\beta t}\left[(A+B)\cos\omega t+(A-B)i\sin\omega t\right]. $$
$\theta$ musi być liczbą rzeczywistą, dlatego $B=\overline{A}$. Niech $A=a+bi$, wtedy $B=a-bi$. Wstawiając to do powyższego równania otrzymamy
$$ \theta=e^{-\beta t}\left(2a\cos\omega t-2b\sin\omega t\right). $$
Ponieważ w nawiasie znajduje się liniowa kombinacja sinusa i cosinusa, możemy zapisać
$$ \theta=\theta_0 e^{-\beta t}\cos(\omega t+\varphi), $$
gdzie $\theta_0$ to amplituda drgań, a $\varphi$ to faza.</p>

<h2 id="pomiar-współczynnika-tłumienia">Pomiar współczynnika tłumienia</h2>
<p>Skonstruowano wahadło z cienkiej, w przybliżeniu nieważkiej nitki oraz śruby zamocowanej na jej końcu. Ponieważ rozmiary śruby były znacznie mniejsze niż długość wahadła, cała masa była w przybliżeniu skoncentrowana w jednym punkcie. Nitka została owinięta wokół cienkiego patyczka służącego jako punkt zaczepienia. Taki sposób zaczepienia linki umożliwił łatwą regulację długości wahadła. Zakładamy, że współczynnik tłumienia jest na tyle mały, że $\omega\approx\omega_0$.</p>

<p>Mierząc wartość $\theta$, gdy $\cos(\omega t+\varphi)=1$ (gdy wahadło jest w swoim maksymalnym wychyleniu) możemy wyznaczyć $\beta$. Czas mierzymy od chwili puszczenia wahadła, więc $\varphi=0$. Warunek zachodzi w bardzo dobrym przybliżeniu dla małych wychyleń (ponieważ $T$ tak naprawdę zależy od amplitudy), gdy $t=nT$, gdzie $T$ to okres wahadła, a $n=0,1,2,\dots$.
$$		\theta(nT)=\theta_0 e^{-\beta nT} $$
$$		\ln{\theta(nT)}=\ln{\theta_0}+-\beta nT $$
Sporządzając wykres $\ln{\theta(nT)}$ możemy wyznaczyć $\beta$ nawet bez znajomości $\theta_0$, ponieważ będzie to współczynnik kierunkowy prostej najlepszego dopasowania.</p>

<p>Wahadło zostało umieszczone w odległości $d=2$cm od biurka, do którego została przyklejona kartka papieru w kratkę. Aby dokładnie zaznaczać kolejne maksymalne wychylenia wahadła, w odległości $d’&gt;1$m od wahadła zostało umieszczone źródło światła, zgodnie ze schematem.</p>
<p align="center">
<img src="/assets/images/2025-06-18/ukladpom.svg" width="500" />
</p>

<p>Cień rzucany przez linkę różnił się o $\Delta x’$ od prawdziwego jej położenia. Przy wymienionych wcześniej wartościach $d$ i $d’$, $\Delta x’&lt;0.02\Delta x$, zatem błąd jest pomijalny. Błąd związany z wyznaczeniem czasu również został pominięty, ponieważ dla tak małych wychyleń okres był w bardzo dobrym przybliżeniu stały i wahadło służyło jako zegar.</p>

<p>Co 5 okresów na kartce były zaznaczane maksymalne wychylenia wahadła. Następnie została zmierzona odległość linii, na której były zaznaczane kolejne położenia wahadła, od punktu zaczepienia wahadła ($h$), aby wyznaczyć $\tan{\theta}=\Delta x/h$. Ponieważ wychylenia były małe, $\theta\approx\tan{\theta}$. Wyniki pomiarów dla $l=0.8\text{m}$ zostały zestawione na poniższych wykresach.</p>
<p align="center">
<img src="/assets/images/2025-06-18/wykresbeta.svg" width="700" />
</p>

<p>W tym układzie otrzymana wartość $\beta$ to
$$	\beta = 0.01478\pm0.0002\frac{1}{\text{s}} $$
Tak mała niepewność wynika z kilku czynników. Niepewność w pomiarze kąta była bardzo niewielka, ponieważ źródło światła umożliwiało precyzyjne wyznaczenie wychylenia wahadła, a ze względu na dużą odległość $h$ zaznaczanych punktów od osi obrotu, niewielkie zmiany kąta powodowały dużą zmianę w odległości $\Delta x$. Niepewność w pomiarze czasu była pomijalna. Niepewność związana z wzięciem logarytmu naturalnego jest dana w przybliżeniu wzorem
$$	\Delta(\ln x)\approx\frac{\Delta x}{x}. $$
W tym przypadku $\Delta x$ było rzędu $10^{-3}$, a $x$ rzędu $10^{-1}$, czyli niepewność była rzędu $10^{-2}$.</p>

<p>Współczynniki tłumienia wyznaczone dla wielu wahadeł umieściłem na widocznym poniżej wykresie zależności $\beta(l)$. Okazało się, że w dobrym przybliżeniu punkty pomiarowe układają się na prostej o współczynniku kierunkowym $a=(0.0073\pm0.0019)\frac{1}{\text{sm}}$ i wyrazie wolnym $b=(0.0092\pm0.0012)\frac{1}{\text{s}}$. Jak wyjaśnić tę obserwację?</p>
<p align="center">
<img src="/assets/images/2025-06-18/wykresbetal.svg" width="700" />
</p>

<h2 id="wyjaśnienie-zaobserwowanej-zależności">Wyjaśnienie zaobserwowanej zależności</h2>
<p>Można spekulować, że wyraz wolny to część współczynnika tłumienia pochodząca od śruby służącej jako masa na końcu wahadła, a $al$ to wkład pochodzący od nitki.</p>

<p>Prawo Stokesa mówi, że wartość siły działającej na kulę o promieniu $R$ poruszającą się z małą prędkością $v$ w płynie jest dana wzorem
$$	F_o=6\pi\mu R v, $$
gdzie $\mu$ to lepkość dynamiczna. Nitkę można przybliżyć jako złożoną z $l/w$ kul o średnicy $w$, gdzie $w$ to również szerokość nitki, ułożonych jedna za drugą. Promień takiej kuli to wtedy $R=w/2$. Całkowita siła działająca na nitkę to suma sił pochodzących od jej wszystkich małych kul. Każda z nich ma jednak inną prędkość, ponieważ znajduje się w innej odległości od osi obrotu.
$$	F=\sum_{i=0}^{l/w}6\pi\mu\frac{w}{2}v_i=3\pi\mu w\omega\sum_{i=0}^{l/w} r_i, $$
gdzie $r_i$ to odległość $i$-tej kuli od osi obrotu. Aby obliczyć sumę, zapiszmy
$$	\sum_{i=0}^{l/w} r_i=\frac{1}{w}\sum_{i=0}^{l/w} r_i w. $$
Ponieważ $w$ jest małe w porównaniu do $l$, możemy aproksymować sumę jako całkę. Wtedy $w = \Delta r_i$, czyli
$$	\frac{1}{w}\sum_{i=0}^{l/w} r_i w\approx\frac{1}{w}\int_{0}^{l}r\,dr=\frac{l^2}{2w}.$$
Wstawiając ten wynik do wcześniejszego wzoru otrzymujemy
$$	F\approx \frac{3}{2}\pi\mu lv,$$
gdzie $v$ to prędkość końca wahadła. Ponieważ $F=2\beta m v$, zachodzi równość
$$
	\beta=\frac{3\pi\mu}{4m}l,
    $$
co wyjaśnia zaobserwowaną zależność.</p>

<h2 id="wyznaczanie-lepkości-dynamicznej-powietrza">Wyznaczanie lepkości dynamicznej powietrza</h2>
<p>Całkowita siła oporu działająca na wahadło to
$$	F=2\beta mv=2almv+2bmv,$$
gdzie m to masa śrubki zawieszonej na końcu wahadła (masa nitki jest pomijalna). Pierwszy wyraz po prawej stronie to siła pochodząca od nitki, czyli przyrównując to do wcześniej obliczonej siły otrzymujemy
$$		2almv=\frac{3}{2}\pi\mu lv $$
$$		4am=3\pi \mu $$
$$		\mu=\frac{4am}{3\pi}. $$
Zmierzona masa śrubki to $m=(4\pm 0.5)$g oraz $a=(0.0073\pm0.0019)\frac{1}{\text{ms}}$. Przy tych danych
	$$ \mu=(12.4\pm4.8)\times 10^{-6}\text{ Pa s},$$
przy czym tablicowa wartość $\mu$ dla powietrza w temperaturze $293\text{K}$ to $\mu=18.13\times 10^{-6}\text{ Pa s}$.</p>

<h2 id="wyznaczanie-gęstości-powietrza">Wyznaczanie gęstości powietrza</h2>
<p>Kinetyczna teoria gazów daje następujący wzór dla rozrzedzonych gazów:
$$	\mu=\alpha\rho\lambda\sqrt{\frac{2k_B T}{\pi m}},$$
gdzie bezwymiarowy współczynnik $\alpha\approx 1$, $\rho$ to gęstość gazu, $\lambda$ to średnia droga swobodna w tym gazie, $T$ to temperatura, a $m$ to masa cząsteczkowa. Przekształćmy ten wzór do postaci
$$	\rho=\frac{\mu}{\alpha\lambda}\sqrt{\frac{\pi m}{2k_B T}}.$$
Dla powietrza $m\approx29\text{u}\approx 4.28\times 10^{-26}\text{kg}$, $\lambda\approx6,6\times 10^{-8}$m. Temperatura podczas pomiarów wynosiła ok. $T\approx293\text{K}$. Wstawiając te dane do wzoru otrzymujemy wynik 
$$	\rho=(0.77\pm0.30)\frac{\text{kg}}{\text{m}^3},$$
przy czym tablicowa wartość w tej temperaturze to $\rho=1.20\frac{\text{kg}}{\text{m}^3}$. Wynik jest obarczony dużą niepewnością spowodowaną głównie niepewnością $m$ i $\mu$. Należy również zauważyć, że prawdziwa wartość $\rho$ nie mieści się w przedziale niepewności. Jest to najprawdopodobniej spowodowane przybliżeniem nitki jako złożonej z wielu kul.</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Tłumione wahadło matematyczne Rozważmy najprostszy model wahadła. Jest to masa punktowa $m$ zawieszona na nieważkiej lince o długości $l$. Na wahadło działa siła ciężkości $\mathbf{Q}$, która rozkłada się na składową radialną i styczną do linki oraz siła reakcji linki $\mathbf{F_r}$, która równoważy $\mathbf{Q_r}$. Na masę działa również siła oporu $\mathbf{F_o}$. Poniżej został przedstawiony schemat tego układu.]]></summary></entry></feed>