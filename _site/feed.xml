<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-08-08T13:51:23+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">bwegrzyn0.github.io</title><subtitle>Fizyka i programowanie</subtitle><entry><title type="html">Mechanika Lagrange’a, część 4: Zasady zachowania</title><link href="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-4-zasady-zachowania" rel="alternate" type="text/html" title="Mechanika Lagrange’a, część 4: Zasady zachowania" /><published>2025-08-04T00:00:00+02:00</published><updated>2025-08-04T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-4-zasady-zachowania</id><content type="html" xml:base="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-4-zasady-zachowania"><![CDATA[<h2 id="uogólnienie-na-układ-wielu-cząstek">Uogólnienie na układ wielu cząstek</h2>
<p>Do tej pory rozważaliśmy układ złożony jedynie z jednej cząstki. Wprowadzenie większej liczby cząstek daje nam więcej współrzędnych uogólnionych, które definiujemy jako zestaw najmniejszej liczby współrzędnych jednoznacznie określających stan układu. Na przykład, dla 2 cząstek w przestrzeni 3-wymiarowej mamy 6 współrzędnych uogólnionych, a dla wahadła podwójnego - jedynie 2.</p>

<p>Lagrażjan dla układu $N$ cząstek o $n$ współrzędnych uogólnionych ma postać
$$ \mathcal{L} = T(\dot{q}_1, \dot{q}_2, \dots, \dot{q}_n, t) - U(q_1, q_2, \dots, q_n, t), $$
gdzie
$$ T(\dot{q}_1, \dot{q}_2, \dots, \dot{q}_n, t)=\frac{1}{2}m_1\mathbf{v}_1+\frac{1}{2}m_2\mathbf{v}_2+\dots+\frac{1}{2}m_N\mathbf{v}_N, $$
przy czym $\mathbf{r}_\alpha$ to położenie $\alpha$-tej cząstki, a $m_\alpha$ to jej masa.</p>

<p>Dla każdej ze współrzędnych uogólnionych mamy równanie Lagrange’a:
$$ \frac{\partial \mathcal{L}}{\partial q_i}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial \dot{q_i}} = 0. $$
<a href="https://bwegrzyn0.github.io/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-3-uk%C5%82ady-nieswobodne" target="_blank">Dowód prawdziwości równań Lagrange’a dla jednej cząstki w układzie nieswobodnym</a> można łatwo uogólnić dla wielu cząstek.</p>

<h3 id="przykład">Przykład</h3>
<p>Rozważmy układ przedstawiony na poniższym rysunku.</p>

<p align="center">
<img src="/assets/images/2025-08-04/sprezyny.svg" width="500" />
</p>

<p>Sprężyna o współczynniku sprężystości $k_1$ jest przymocowana do ściany, do niej przymocowany jest bloczek o masie $m_1$, a do niego sprężyna o współczynniku sprężystości $k_2$ z bloczkiem o masie $m_2$.</p>

<p>Położenie pierwszego bloczka oznaczmy jako $x_1$, a drugiego jako $x_2$. Ich położenia równowagi oznaczmy kolejno jako $x_{01}$ i $x_{02}$. Łatwo zauważyć, że $x_1=x_{01}+\Delta x_{1}$ oraz $x_2=x_{02}+\Delta x_1 + \Delta x_2$, gdzie $\Delta x_1$ oraz $\Delta x_2$ to rozciągnięcia sprężyn.</p>

<p>Energia kinetyczna tego układu to
$$ T=\frac{1}{2}m_1 \dot{x}_1^2+\frac{1}{2}m_2 \dot{x}_1^2=\frac{1}{2}m_1\Delta\dot{x}_1^2+\frac{1}{2}m_2\left(\Delta \dot{ x}_1+\Delta \dot{ x}_2\right)^2, $$
a energia potencjalna to
$$ U=\frac{1}{2}k_1\Delta x_1^2+\frac{1}{2}k_2\Delta x_2^2. $$
Po obliczeniu Lagranżjanu, wstawieniu go do dwóch równań i uproszczeniu wyrażeń otrzymujemy układ
$$ \begin{cases}
m_1\Delta\ddot{x}_1=-k_1\Delta x_1+k_2\Delta x_2 \\ m_2\Delta \ddot{x}_2=-k_2\Delta x_2-m_2\Delta \ddot{x}_1
\end{cases} $$
W pierwszym równaniu z łatwością można wyróżnić siły pochodzące od obu sprężyn, a w drugim siłę sprężystości i siłę bezwładności.</p>

<h2 id="zachowanie-pędu">Zachowanie pędu</h2>
<p>Rozważmy izolowany układ $N$ cząstek o położeniach $\mathbf{r}_1, \mathbf{r}_2, \dots, \mathbf{r}_N$. Przesuńmy wszystkie cząstki o mały wektor $\boldsymbol{\varepsilon}=\left(\varepsilon, \varepsilon, \dots, \varepsilon\right)$ (ma tyle składowych ile jest współrzędnych uogólnionych).</p>

<p>Ponieważ układ jest izolowany, potencjał pochodzi <em>wyłącznie</em> od cząstek w naszym układzie (nie mamy zewtnętrznych pól). Ponieważ wszystkie cząstki zostały przesunięte, ich względne położenia nie zmieniły się, a co za tym idzie energia potencjalna również. Dlatego mamy $\delta U=0$.</p>

<p>Ponieważ $\boldsymbol{\varepsilon}$ to stały wektor, prędkości cząstek się nie zmieniły, zatem $\delta T=0$.</p>

<p>Zmiana lagranżjanu to
$$ \delta \mathcal{L}=\delta T -\delta U=0,$$
ale również
$$ \delta \mathcal{L}=\frac{\partial \mathcal{L}}{\partial q_1}\varepsilon+\frac{\partial \mathcal{L}}{\partial q_2}\varepsilon+\dots+\frac{\partial \mathcal{L}}{\partial q_n}\varepsilon. $$
Z powyższych równań wynika, że
$$ \sum_{i=1}^n \frac{\partial \mathcal{L}}{\partial q_i}\varepsilon = 0, $$
a ponieważ $\varepsilon\neq 0$
$$ \sum_{i=1}^n \frac{\partial \mathcal{L}}{\partial q_i}= 0. $$
Z równania Lagrange’a mamy 
$$ \frac{\partial \mathcal{L}}{\partial q_i}=\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial \dot{q}_i}, $$
czyli
$$ \frac{d}{dt}\sum_{i=1}^n \frac{\partial \mathcal{L}}{\partial \dot{q}_i}= 0 $$
$$ \sum_{i=1}^n p_i = const. $$
Jeśli zdefiniujemy wektor $\mathbf{P}=\left(p_1, p_2, \dots, p_n\right)$, to
$$ \boxed{\mathbf{P}=\mathbf{const.}} $$
w układzie izolowanym.</p>

<h2 id="zachowanie-momentu-pędu">Zachowanie momentu pędu</h2>
<p>Rozważmy układ izolowany taki, jak w przypadku zachowania pędu. Tym razem układ obrócimy o mały kąt $\delta\theta$ wokół, powiedzmy, osi $z$. Oznacza to, że wszystkie wektory położeń zostaną przesunięte o $\mathbf{\delta r}_\alpha$ oraz wektory prędkości o $\mathbf{\delta v}_\alpha$.</p>

<p align="center">
<img src="/assets/images/2025-08-04/obrot.svg" width="500" />
</p>

<p>Załóżmy, że wektor $\mathbf{r}_\alpha$ tworzy kąt $\phi_\alpha$ z osią $z.$ Obrócony wektor to $\mathbf{r}_\alpha’$ i tworzy on taki sam kąt z osią $z$ (ponieważ wokół niej zachodzi obrót). Odległość wektora $\mathbf{r}_\alpha$ i $\mathbf{r}_\alpha’$ od osi $z$ na kierunku do niej prostopadłym to $r_\alpha\sin\phi_\alpha$. Z tego powodu wartość wektora zmiany położenia to 
$$ \delta r_\alpha=r_\alpha\sin\phi_\alpha\,\delta\theta. $$
Niech wektor $\delta\boldsymbol{\theta}$ będzie skierowany zgodnie ze zwrotem osi $z$ (reguła prawej ręki). Na podstawie rysunku możemy stwierdzić, że 
$$ \delta\mathbf{r}_\alpha=\delta\boldsymbol{\theta}\times\mathbf{r}_\alpha $$
i analogicznie dla wektora prędkości:
$$ \delta\mathbf{v}_\alpha=\delta\boldsymbol{\theta}\times\mathbf{v}_\alpha. $$</p>

<p>Oczekujemy, że przy obrocie lagranżjan układu nie ulegnie zmianie, czyli 
$$ \delta \mathcal{L}=\sum_\alpha \left[\frac{\partial\mathcal{L}}{\partial \mathbf{r}_\alpha}\cdot\delta\mathbf{r}_\alpha + \frac{\partial\mathcal{L}}{\partial \mathbf{v}_\alpha}\cdot\delta\mathbf{v}_\alpha\right]=0. $$
Podstawiając wcześniej obliczone wektory otrzymujemy
$$ \sum_\alpha \left[\frac{\partial\mathcal{L}}{\partial \mathbf{r}_\alpha}\cdot\left(\delta\boldsymbol{\theta}\times\mathbf{r}_\alpha\right) + \frac{\partial\mathcal{L}}{\partial \mathbf{v}_\alpha}\cdot\left(\delta\boldsymbol{\theta}\times\mathbf{v}_\alpha\right)\right]=0. $$
Możemy zamienić wektory w iloczynie wektorowym i wyjąć $\delta\boldsymbol{\theta}$ poza sumę:
$$ \delta\boldsymbol{\theta}\cdot\sum_\alpha \left[\frac{\partial\mathcal{L}}{\partial \mathbf{r}_\alpha}\times\mathbf{r}_\alpha + \frac{\partial\mathcal{L}}{\partial \mathbf{v}_\alpha}\times\mathbf{v}_\alpha\right]=0 $$
i wykorzystajmy fakt, że $\partial\mathcal{L}/\partial \mathbf{r}_\alpha=\dot{\mathbf{p}}_\alpha$ oraz $\partial\mathcal{L}/\partial \mathbf{v}_\alpha=\mathbf{p}_\alpha$: 
$$ \delta\boldsymbol{\theta}\cdot\sum_\alpha \left[\dot{\mathbf{p}}_\alpha\times\mathbf{r}_\alpha + \mathbf{p}_\alpha\times\mathbf{v}_\alpha\right]=0. $$
W nawiasie kwadratowym rozpoznajemy pochodną iloczynu funkcji:
$$ \delta\boldsymbol{\theta}\cdot\sum_\alpha \frac{d}{dt} \left[\mathbf{p}_\alpha\times\mathbf{r}_\alpha\right]=0. $$
Ponieważ $\delta\boldsymbol{\theta}\neq 0$, suma wynosi $0$ i sprowadza się do
$$ \boxed{\mathbf{M}=\sum_\alpha \mathbf{r}_\alpha\times\mathbf{p}_\alpha=\mathbf{const.}} $$
Oznacza to, że całkowity <strong>moment pędu</strong> jest zachowany w układzie izolowanym.</p>

<h2 id="zachowanie-energii">Zachowanie energii</h2>
<p>Załóżmy, że współrzędne są <strong>naturalne</strong>, to znaczy lagranżjan nie zależy jawnie od czasu, $\partial \mathcal{L}/\partial t=0$.</p>

<p>Wyznaczmy pochodną lagranżjanu po czasie:
$$ \frac{d\mathcal{L}}{dt}=\sum_{i=1}^n \frac{\partial\mathcal{L}}{\partial q_i}\dot{q}_i+\sum_{i=1}^n \frac{\partial\mathcal{L}}{\partial \dot{q}_i}\ddot{q}_i+\frac{\partial\mathcal{L}}{\partial t}. $$
$\partial \mathcal{L}/\partial t=0$, a $\partial \mathcal{L}/\partial q_i$ możemy wyznaczyć z równań Langrange’a. Po podstawieniu dostajemy
$$ \frac{d\mathcal{L}}{dt}=\sum_{i=1}^n \left[\frac{d}{dt}  \frac{\partial\mathcal{L}}{\partial \dot{q}_i}\dot{q}_i +\frac{\partial\mathcal{L}}{\partial \dot{q}_i}\ddot{q}_i\right].$$
Zauważmy, że wyrażenie pod sumą to pochodna iloczynu funkcji, dlatego
$$ \frac{d\mathcal{L}}{dt}=\sum_{i=1}^n\frac{d}{dt}\left[\frac{\partial\mathcal{L}}{\partial \dot{q}_i}\dot{q}_i\right]. $$
Odejmując obustronnie wyrażenie z prawej strony otrzymujemy 
$$ \sum_{i=1}^n\frac{d}{dt}\left[\frac{\partial\mathcal{L}}{\partial \dot{q}_i}\dot{q}_i\right]-\frac{d\mathcal{L}}{dt}=0$$
$$ \sum_{i=1}^n p_i\dot{q}_i-\mathcal{L}=const.$$
gdzie skorzystałem z faktu, że $\partial\mathcal{L}/\partial \dot{q}_i=p_i$. Powyższa wielkość nazywa się <strong>hamiltonianem</strong> $\mathcal{H}$.
Wart uwagi jest fakt, że powyższe równanie jest takie samo jak <a href="https://bwegrzyn0.github.io/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-1-r%C3%B3wnanie-eulera-lagrangea" target="_blank">całka pierwsza wyprowadzona na przykładzie błony mydlanej w jednym z poprzednich artykułów.</a></p>

<p>Obliczmy bezpośrednio hamiltonian dla układu $N$ cząstek o $n$ współrzędnych uogólnionych. Aby obliczyć $p_i$ musimy obliczyć pochodną $\partial\mathcal{L}/\partial \dot{q}_i$, a ponieważ $U$ nie zależy od $\dot{q}_i$, jest to po prostu $\partial T/\partial \dot{q}_i$. $T$ jest dane wzorem
$$ T=\frac{1}{2}\sum_{\alpha=1}^N m_\alpha \mathbf{v}_{\alpha} \cdot \mathbf{v}_{\alpha}. $$
Obliczmy $\mathbf{v}_\alpha$ za pomocą reguły łańcuchowej:
$$ \mathbf{v}_\alpha=\frac{\partial \mathbf{r}_\alpha}{\partial q_1}\dot{q}_1+\frac{\partial \mathbf{r}_\alpha}{\partial q_2}\dot{q}_2+\dots+\frac{\partial \mathbf{r}_\alpha}{\partial q_n}\dot{q}_n=\sum_{j=1}^n \frac{\partial \mathbf{r}_\alpha}{\partial q_j}\dot{q}_j $$
Iloczyn wektorowy będzie równy
$$ \mathbf{v}_\alpha\cdot\mathbf{v}_\alpha=\sum_j \sum_k \frac{\partial \mathbf{r}_\alpha}{\partial q_j}\cdot\frac{\partial \mathbf{r}_\alpha}{\partial q_k} \dot{q}_j \dot{q}_k. $$
Pomijam granice sumowania dla przejrzystości zapisu. Zauważmy, że 
$$ \frac{\partial T}{ \partial \dot{q}_i}=\frac{1}{2}\sum_{\alpha} m_\alpha\frac{\partial}{\partial \dot{q}_i} \left(\mathbf{v}_\alpha\cdot\mathbf{v}_\alpha\right), $$
więc obliczmy tę pochodną. Pochodna wszystkich wyrazów dla których $j\neq i$ oraz $k\neq i$ jednocześnie będzie wynosić 0. Pozostają nam wyrazy, dla których $j=i$ oraz $k=i$. To daje nam
$$\frac{\partial}{\partial \dot{q}_i} \left(\mathbf{v}_\alpha\cdot\mathbf{v}_\alpha\right)=
\frac{\partial}{\partial \dot{q}_i} \sum_j \sum_k \frac{\partial \mathbf{r}_\alpha}{\partial q_j}\cdot\frac{\partial \mathbf{r}_\alpha}{\partial q_k} \dot{q}_j \dot{q}_k= \sum_j \frac{\partial \mathbf{r}_\alpha}{\partial q_j}\cdot\frac{\partial \mathbf{r}_\alpha}{\partial q_i} \dot{q}_j+\sum_k \frac{\partial \mathbf{r}_\alpha}{\partial q_i}\cdot\frac{\partial \mathbf{r}_\alpha}{\partial q_k} \dot{q}_k. $$
Obydwie sumy są dokładnie takie same, więc mamy
$$ 2\sum_j \frac{\partial \mathbf{r}_\alpha}{\partial q_j}\cdot\frac{\partial \mathbf{r}_\alpha}{\partial q_i} \dot{q}_j.$$
Po wstawieniu do wyrażenia na pęd otrzymamy
$$ p_i=\sum_\alpha m_\alpha\sum_j \frac{\partial \mathbf{r}_\alpha}{\partial q_j}\cdot\frac{\partial \mathbf{r}_\alpha}{\partial q_i} \dot{q}_j.$$
Wstawmy to do hamiltonianu:
$$ \mathcal{H}=\sum_i  \dot{q}_i\sum_\alpha m_\alpha\sum_j \frac{\partial \mathbf{r}_\alpha}{\partial q_j}\cdot\frac{\partial \mathbf{r}_\alpha}{\partial q_i} \dot{q}_j  - \mathcal{L}. $$
$\dot{q}_i$ możemy przenieść wewnątrz sumy po $j$:
$$ \mathcal{H}= \sum_\alpha m_\alpha\sum_i\sum_j \frac{\partial \mathbf{r}_\alpha}{\partial q_j}\cdot\frac{\partial \mathbf{r}_\alpha}{\partial q_i} \dot{q}_j \dot{q}_i - \mathcal{L}. $$
Podwójną sumę rozpoznajemy jako $\mathbf{v}_\alpha\cdot\mathbf{v}_\alpha$. Wtedy cała suma po $\alpha$ to po prostu $2T$. Pamiętając, że $\mathcal{L}=T-U$, otrzymujemy następujący wynik:
$$ \boxed{\mathcal{H}=T+U=const.} $$
gdy współrzędne są naturalne (lagranżjan nie zależy jawnie od czasu).</p>

<p>Oczywistym faktem jest, że jeśli energia potencjalna $U$ zmienia się w czasie (np. z jakiegoś powodu zmienia się przyspieszenie ziemskie), energia w układzie nie będzia zachowana.</p>

<p>$T$ jest zależne od czasu np. w sytuacji, gdy wagon, na którego suficie przyczepione jest wahadło, porusza się z przyspieszeniem $a$ wzdłuż osi $x$. Położenie wahadła względem ziemi charakteryzują wtedy współrzędne $x$ oraz $\theta$. Energia kinetyczna tego wahadła będzie wyrażała się wzorem
$$ T=\frac{1}{2}ml^2\dot{\theta}^2+\frac{1}{2}ma^2t^2, $$
gdzie $l$ to długość wahadła, a $m$ to masa zaczepiona na jego końcu. Lagranżjan zależy jawnie od czasu, a energia oczywiście nie jest zachowana, ponieważ wahadło zyskuje wraz z wagonem energię kinetyczną. Bardziej <em>naturalnym</em> wyborem układu współrzędnych w tej sytuacji jest układ związany z wagonem (w tym układzie współrzędne są faktycznie <em>naturalne</em>). Siłę bezwładności możemy modelować wtedy jak zadaną potencjałem proporcjonalnym do $x$.</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Uogólnienie na układ wielu cząstek Do tej pory rozważaliśmy układ złożony jedynie z jednej cząstki. Wprowadzenie większej liczby cząstek daje nam więcej współrzędnych uogólnionych, które definiujemy jako zestaw najmniejszej liczby współrzędnych jednoznacznie określających stan układu. Na przykład, dla 2 cząstek w przestrzeni 3-wymiarowej mamy 6 współrzędnych uogólnionych, a dla wahadła podwójnego - jedynie 2.]]></summary></entry><entry><title type="html">Transformacja Fouriera</title><link href="http://localhost:4000/narz%C4%99dzia%20matematyczne/transformacja-fouriera" rel="alternate" type="text/html" title="Transformacja Fouriera" /><published>2025-08-02T00:00:00+02:00</published><updated>2025-08-02T00:00:00+02:00</updated><id>http://localhost:4000/narz%C4%99dzia%20matematyczne/transformacja-fouriera</id><content type="html" xml:base="http://localhost:4000/narz%C4%99dzia%20matematyczne/transformacja-fouriera"><![CDATA[<h2 id="szeregi-fouriera">Szeregi Fouriera</h2>
<p>Fourier zaproponował, że funkcje okresowe (tzn. $f(t)=f(t+\tau)$) spełniające dostateczne warunki (znaczna większość funkcji występujących w zastosowaniach je spełnia) można przedstawić w postaci <strong>szeregu Fouriera</strong>
$$ f(t)=\sum_{n=0}^\infty a_n\cos\left(n\omega t\right)+b_n\sin\left(n\omega t\right), $$
gdzie $\omega=2\pi/\tau$.
Wiadomo, że dowolna liniowa kombinacja sinusa i cosinusa to cosinus z przesunięciem fazowym, zatem
$$ f(t)=\sum_{n=0}^\infty c_n\cos\left(n\omega t+\phi_n\right). $$
Wygodniej jest operować na funkcji wykładniczej niż trygonometrycznej. Ponieważ $\cos x=(e^{ix}+e^{-ix})/2$, 
$$ c_n\cos\left(n\omega t+\phi_n\right)=\frac{c_n}{2}\left(e^{i(n\omega_0 t+\phi_n)}+e^{-i(n\omega_0 t+\phi_n)}\right)=a_n e^{\phi_n}e^{in\omega_0 t}+a_{-n}e^{\phi_{-n}}e^{-in\omega_0 t}=\hat{a}_n e^{in\omega_0 t}+\hat{a}_{-n}e^{-in\omega_0 t} $$
gdzie $a_n$ i $a_{-n}$ to pewne współczynniki. To pozwala nam zapisać
$$ \boxed{f(t)=\sum_{n=-\infty}^\infty \hat{a}_n e^{i n\omega t},} $$
gdzie $n$ zaczyna się w $-\infty$, ponieważ musimy wziąć pod uwagę oba wyrazy.
Chcemy wyznaczyć współczynniki $\hat{a}_n$. W tym celu pomnóżmy obie strony powyższej równości przez $e^{-i m\omega t}$, gdzie $m$ to liczba całkowita:
$$ f(t)e^{-i m\omega t}=\sum_{n=-\infty}^\infty \hat{a}_n e^{i n\omega t}e^{-i m\omega t}=\sum_{n=-\infty}^\infty \hat{a}_n e^{i (n-m)\omega t} $$
Pocałkujmy teraz obustronnie po czasie na przedziale $[0, \tau]$:
$$ \int_0^\tau f(t)e^{-i m\omega t}\,dt=\sum_{n=0}^\infty\int_0^\tau\hat{a}_n e^{i (n-m)\omega t}\,dt. $$
Zajmijmy się całką wewnątrz sumy. Gdy $n=m$, całka ta wynosi $\hat{a}_n\tau$, a w przeciwnym wypadku 
$$ \int_0^\tau\hat{a}_n e^{i (n-m)\omega t}\,dt=\hat{a}_n\left[\frac{1}{i\omega(n-m)}e^{i (n-m)\omega t}\right]_0^\tau=\frac{\hat{a}_n}{i\omega(n-m)}\left[e^{i(n-m)\cdot 2\pi}-1\right],$$
gdzie skorzystałem z faktu, że $\omega\tau=2\pi$ oraz $e^0=1$. Zauważmy, że $2\pi(n-m)$ będzie <strong>zawsze całkowitą wielokrotnością $2\pi$</strong>, przez co $e^{i(n-m)\cdot 2\pi}=1$. Z tego powodu całka ta wynosić będzie 0. Ponieważ stwierdziliśmy, że wyrażenie pod sumą zeruje się dla $n\neq m$, pozostaje nam tylko $n=m$:
$$ \int_0^\tau f(t)e^{-i n\omega t}\,dt=\tau\hat{a}_n, $$
a stąd
$$ \boxed{\hat{a}_n=\frac{1}{\tau}\int_0^\tau f(t)e^{-i n\omega t}\,dt.} $$
$\hat{a}_n$ są nazywane <strong>współczynnikami Fouriera</strong>.</p>

<h3 id="przykład">Przykład</h3>
<p>Niech będzie dana funkcja opisująca falę kwadratową:
$$ f(t) = \begin{cases}
1\quad t\in\left[n\tau, \left(n+\frac{1}{2}\right)\tau\right] \\ 0\quad\text{ dla innych } t,
\end{cases} $$
gdzie $n$ to liczba całkowita.</p>

<p>Zacznijmy od przypadku $n=0$, ponieważ wtedy funkcja wykładnicza pod całką wynosi $1$. Pozostawia to nas z
$$ \hat{a}_0=\frac{1}{\tau}\int_0^\tau f(t)\,dt=\frac{1}{\tau}\int_0^{\tau/2} \,dt=\frac{1}{2}, $$
gdzie skorzystałem z faktu, że na przedziale $\left[0,\tau\right]$ $f(t)$ jest różne od $0$ tylko dla $\left[0,\tau/2\right]$. Z tego samego faktu możemy skorzystać rozważając przypadek $n\neq 0$:
$$ \hat{a}_n=\frac{1}{\tau}\int_0^{\tau/2}e^{-i n\omega t}\,dt=-\frac{1}{\tau in\omega}\left[ e^{-i n\omega t}\right]_0^{\tau/2}=-\frac{1}{\tau in\omega}\left[e^{-in\pi}-1\right]=-\frac{1}{2\pi in}\left[e^{-in\pi}-1\right].$$
Dla $n$ parzystych $e^{-in\pi}=1$, a dla nieparzystych $-1$, zatem
$$ \hat{a}_n=\begin{cases}
\frac{1}{2}\quad n=0 \\ 0 \quad n \text{ parzyste} \\ \frac{1}{in\pi} \quad n\text{ nieparzyste}.
\end{cases} $$
Współczynniki te dają nam szereg
$$ f(t)=\frac{1}{2}+\frac{1}{i\pi}e^{i\omega t}-\frac{1}{i\pi}e^{-i\omega t}+\frac{1}{3i\pi}e^{3i\omega t}-\frac{1}{3i\pi}e^{-3i\omega t}+\dots, $$
co po przekształceniach daje nam
$$ f(t)=\frac{1}{2}+\frac{2}{\pi}\sin\omega t+\frac{2}{3\pi}\sin 3\omega t+\frac{2}{5\pi}\sin 5\omega t+\dots $$
Wykres funkcji oraz pierwszych 3 i 10 wyrazów szeregu został umieszczony na poniższym rysunku.</p>
<p align="center">
<img src="/assets/images/2025-08-02/falaKwadratowa.svg" width="700" />
</p>

<h2 id="transformacja-fouriera">Transformacja Fouriera</h2>
<p>Nie tylko funkcje okresowe można zapisać za pomocą sinusów i cosinusów. Dla funkcji, które nie są okresowe możemy przyjąć $\tau\to\infty$ oraz $2\pi/\tau\to d\omega$. Wtedy również $\hat{a}_n\to \hat{a}(\omega)\,d\omega$. W granicy suma przechodzi w całkę i otrzymujemy
$$ \boxed{f(t) = \int_{-\infty}^\infty \hat{a}(\omega)e^{i\omega t}\,d\omega} $$
oraz 
$$ \hat{a}(\omega)\,d\omega = \frac{d\omega}{2\pi}\int_0^\infty f(t)e^{-i\omega t}\,dt $$
$$ \boxed{\hat{a}(\omega) = \frac{1}{2\pi}\int_0^\infty f(t)e^{-i\omega t}\,dt}. $$
Drugi wzór nosi nazwę <strong>transformacji Fouriera</strong>, a pierwszy <strong>odwrotnej transformacji Fouriera</strong>.</p>

<h3 id="przykład-1">Przykład</h3>
<p>Rozważmy falę modulowaną przez funkcję Gaussa
$$ f(t)=e^{-t^2/2\sigma^2}\cos \omega_0 t, $$
której wykres dla róznych wartości $\sigma$ i $\omega_0$ przedstawiony jest poniżej. Widzimy, że zwiększając $\sigma$ ,,poszerzamy’’ falę, a zwiększając $\omega_0$ zwiększamy częstotliwość.</p>
<p align="center">
<img src="/assets/images/2025-08-02/falaModulowana.svg" width="700" />
</p>
<p>Aby znaleźć transformację Fouriera powyższej funkcji, zapiszymy $\cos$ w postaci zespolonej:
$$ f(t)=\frac{1}{2}e^{-t^2/2\sigma^2}\left(e^{i\omega_0 t}+e^{-i\omega_0 t}\right) $$
i wstawmy do wzoru na transformację
$$ \hat{a}(\omega)=\frac{1}{2\pi}\int_{-\infty}^\infty f(t) e^{-i\omega t}\,dt=\frac{1}{4\pi} \int_{-\infty}^\infty e^{-t^2/2\sigma^2}e^{i\omega_0 t}e^{-i\omega t}+\frac{1}{4\pi}\int_{-\infty}^\infty e^{-t^2/2\sigma^2}e^{-i\omega_0 t}e^{-i\omega t}\,dt  $$
Rozważmy teraz całkę
$$ \int_{-\infty}^\infty e^{-t^2/2\sigma^2} e^{-i\omega’ t}\,dt. $$
W naszym przypadku dla pierwszej całki $\omega’ =\omega-\omega_0$, a dla drugiej $\omega’ =\omega+\omega_0$. Aby obliczyć powyższą całkę dopełnijmy kwadrat:
$$ \int_{-\infty}^\infty e^{-t^2/2\sigma^2-i\omega’ t}\,dt=\int_{-\infty}^\infty e^{-(t/\sqrt{2}\sigma+i\omega’\sigma/\sqrt{2})^2-\omega’^2\sigma^2/2}\,dt= $$
$$ =e^{-\omega’^2\sigma^2/2}\int_{-\infty}^\infty e^{-(t/\sqrt{2}\sigma+i\omega’\sigma/\sqrt{2})^2}\,dt. $$
Podstawmy $u=t/\sqrt{2}\sigma+i\omega’\sigma/\sqrt{2}$, czyli $dt=\sqrt{2}\sigma\,du$. Granice całkowania pozostają niezmienione:
$$ e^{-\omega’^2\sigma^2/2}\int_{-\infty}^\infty e^{-u^2}\sqrt{2}\sigma\,du = \sqrt{2\pi}\sigma e^{-\omega’^2\sigma^2/2}. $$
Wstawmy ten wynik do wzoru na $\hat{a}$:
$$ \hat{a}(\omega)=\frac{\sigma}{2\sqrt{2\pi}}\left(e^{-(\omega_0+\omega)^2\sigma^2/2}+e^{-(\omega_0-\omega)^2\sigma^2/2}\right) $$
Powyższe wyrażenie można uprościć do
$$ \hat{a}(\omega)=\frac{\sigma}{\sqrt{2\pi}}e^{-(\omega_0^2+\omega^2)\sigma^2/2}\cosh\left(\omega\omega_0\sigma^2\right). $$
$\hat{a}$ możemy podnieść do kwadratu aby otrzymać <strong>widmo mocy</strong> $S(\omega)$:
$$ S(\omega)=\frac{\sigma^2}{2\pi}e^{-(\omega_0^2+\omega^2)\sigma^2}\cosh^2\left(\omega\omega_0\sigma^2\right). $$
Zostało ono przedstawione dla wcześniejszych fal na poniższym wykresie:</p>
<p align="center">
<img src="/assets/images/2025-08-02/widmoMocy.svg" width="700" />
</p>
<p>Funkcje $S(\omega)$ na wykresie zostały znormalizowane, aby można było dostrzec ich kształt i wzajemne powiązanie.</p>

<p>Jak widać, jest ono symetryczne względem osi $y$. Jest tak, ponieważ rozważane fale zawierają tylko składową parzystą $\cos$. Dla funkcji $\cos$ nie ma znaczenia znak częstotliwości, a więc moc jest rozłożona równomiernie między $\omega$ i $-\omega$. Zgodnie z oczekiwaniami najwięcej mocy jest skupionej w częstotliwości $\omega_0$. Zauważmy również, że im bardziej ,,rozwlekła’’ fala, tym bardziej moc jest skupiona wokół $\omega_0$ (czerwony wykres). Jest to spodwodowane faktem, że bardziej ,,rozwlekła’’ fala bardziej ,,przypomina’’ zwykłą falę.</p>]]></content><author><name></name></author><category term="Narzędzia matematyczne" /><summary type="html"><![CDATA[Szeregi Fouriera Fourier zaproponował, że funkcje okresowe (tzn. $f(t)=f(t+\tau)$) spełniające dostateczne warunki (znaczna większość funkcji występujących w zastosowaniach je spełnia) można przedstawić w postaci szeregu Fouriera $$ f(t)=\sum_{n=0}^\infty a_n\cos\left(n\omega t\right)+b_n\sin\left(n\omega t\right), $$ gdzie $\omega=2\pi/\tau$. Wiadomo, że dowolna liniowa kombinacja sinusa i cosinusa to cosinus z przesunięciem fazowym, zatem $$ f(t)=\sum_{n=0}^\infty c_n\cos\left(n\omega t+\phi_n\right). $$ Wygodniej jest operować na funkcji wykładniczej niż trygonometrycznej. Ponieważ $\cos x=(e^{ix}+e^{-ix})/2$, $$ c_n\cos\left(n\omega t+\phi_n\right)=\frac{c_n}{2}\left(e^{i(n\omega_0 t+\phi_n)}+e^{-i(n\omega_0 t+\phi_n)}\right)=a_n e^{\phi_n}e^{in\omega_0 t}+a_{-n}e^{\phi_{-n}}e^{-in\omega_0 t}=\hat{a}_n e^{in\omega_0 t}+\hat{a}_{-n}e^{-in\omega_0 t} $$ gdzie $a_n$ i $a_{-n}$ to pewne współczynniki. To pozwala nam zapisać $$ \boxed{f(t)=\sum_{n=-\infty}^\infty \hat{a}_n e^{i n\omega t},} $$ gdzie $n$ zaczyna się w $-\infty$, ponieważ musimy wziąć pod uwagę oba wyrazy. Chcemy wyznaczyć współczynniki $\hat{a}_n$. W tym celu pomnóżmy obie strony powyższej równości przez $e^{-i m\omega t}$, gdzie $m$ to liczba całkowita: $$ f(t)e^{-i m\omega t}=\sum_{n=-\infty}^\infty \hat{a}_n e^{i n\omega t}e^{-i m\omega t}=\sum_{n=-\infty}^\infty \hat{a}_n e^{i (n-m)\omega t} $$ Pocałkujmy teraz obustronnie po czasie na przedziale $[0, \tau]$: $$ \int_0^\tau f(t)e^{-i m\omega t}\,dt=\sum_{n=0}^\infty\int_0^\tau\hat{a}_n e^{i (n-m)\omega t}\,dt. $$ Zajmijmy się całką wewnątrz sumy. Gdy $n=m$, całka ta wynosi $\hat{a}_n\tau$, a w przeciwnym wypadku $$ \int_0^\tau\hat{a}_n e^{i (n-m)\omega t}\,dt=\hat{a}_n\left[\frac{1}{i\omega(n-m)}e^{i (n-m)\omega t}\right]_0^\tau=\frac{\hat{a}_n}{i\omega(n-m)}\left[e^{i(n-m)\cdot 2\pi}-1\right],$$ gdzie skorzystałem z faktu, że $\omega\tau=2\pi$ oraz $e^0=1$. Zauważmy, że $2\pi(n-m)$ będzie zawsze całkowitą wielokrotnością $2\pi$, przez co $e^{i(n-m)\cdot 2\pi}=1$. Z tego powodu całka ta wynosić będzie 0. Ponieważ stwierdziliśmy, że wyrażenie pod sumą zeruje się dla $n\neq m$, pozostaje nam tylko $n=m$: $$ \int_0^\tau f(t)e^{-i n\omega t}\,dt=\tau\hat{a}_n, $$ a stąd $$ \boxed{\hat{a}_n=\frac{1}{\tau}\int_0^\tau f(t)e^{-i n\omega t}\,dt.} $$ $\hat{a}_n$ są nazywane współczynnikami Fouriera.]]></summary></entry><entry><title type="html">fraktale-obrazy: Program umożliwiąjący generowanie fraktali</title><link href="http://localhost:4000/programowanie/fraktale-obrazy-program-umo%C5%BCliwiaj%C4%85cy-generowanie-fraktali" rel="alternate" type="text/html" title="fraktale-obrazy: Program umożliwiąjący generowanie fraktali" /><published>2025-07-31T00:00:00+02:00</published><updated>2025-07-31T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/fraktale-obrazy-program-umo%C5%BCliwiaj%C4%85cy-generowanie-fraktali</id><content type="html" xml:base="http://localhost:4000/programowanie/fraktale-obrazy-program-umo%C5%BCliwiaj%C4%85cy-generowanie-fraktali"><![CDATA[<p align="center">
<img src="/assets/images/2025-07-31/readme_image.jpg" width="700" />
<br />
<em>Obraz wygenerowany z użyciem programu</em>
</p>

<h1 id="fraktale-obrazy">fraktale-obrazy</h1>
<p>Prosty program napisany w C++ z użyciem biblioteki SDL2, który umożliwia generowanie i zapisywanie obrazów fraktali.</p>

<blockquote>
  <p><strong>Uwaga!</strong> <br />
Początkowo miał być to mały projekt, lecz nieco się rozrósł. Program może być niewydajny i zbugowany.</p>
</blockquote>

<p>Jest to <a href="https://github.com/bwegrzyn0/fraktale-obrazy" target="_blank">plik README z repozytorium GitHub</a> przetłumaczony na język polski.</p>

<h2 id="instalacja-programu">Instalacja programu</h2>
<p>Zklonuj repozytorium GitHub:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/bwegrzyn0/fraktale-obrazy
</code></pre></div></div>
<p>i uruchom program za pomocą komendy <code class="language-plaintext highlighter-rouge">./run.out</code>.</p>

<h2 id="użytkowanie">Użytkowanie</h2>
<p>W oknie zobaczysz następujący interfejs:</p>

<p align="center">
<img src="/assets/images/2025-07-31/interface_image.jpg" width="600" />
</p>

<p>Radzę samodzielnie wypróbować poszczególne opcje aby zobaczyć ich efekt na obrazie. Tutaj po krótce omówię każdą z nich:</p>
<ul>
  <li><strong>Brightness multiplier</strong>: mnoży jasność wszystkich pikseli przez zadaną wartość.</li>
  <li><strong>Resolution</strong>: liczba pikseli na jednostkę długosci. Na przykład, jeśli szerokość obszaru (omawiana dalej) wynosi 10, a rozdzielczość wynosi 100, obraz będzie miał szerokość 100 * 10 = 1000 pikseli. Bardzo duże wartości negatywnie wpływają na wydajność programu. Z tego powodu przy oddalaniu widoku rozdzielczość jest dynamicznie zminiejszana (nie ma to wpływu na zapisywany obraz).</li>
  <li><strong>Number of iterations</strong>: liczba iteracji algorytmu IFSP.</li>
  <li><strong>Number of points</strong>: liczba punktów w algorytmie IFSP.</li>
  <li><strong>Area X and Area Y</strong>: współrzędne X i Y obszaru generacji fraktala.</li>
  <li><strong>Area width and Area height</strong>: szerokość i wysokość obszaru generacji fraktala.</li>
  <li><strong>Show area border</strong>: pozwala przełączać widoczność czerwonej granicy wokół obszaru generacji fraktala.</li>
  <li>
    <p><strong>Transformation parameters</strong>: maksymalnie można mieć 4 transformacje. Każdą z nich charakteryzuje 7 liczb. Współrzędne są transformowane według następujących zależności:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>transformowane_x = a_x * x + b_x * y + c_x
transformowane_y = a_y * x + b_y * y + c_y
</code></pre></div>    </div>
    <p>Każda transformacja ma swoje prawdopodobieństwo, które nie wpływa na kształt fraktala. Zmienia ono jedynie gęstość rozłożenia punktów na nim.</p>
    <blockquote>
      <p><strong>Wskazówka</strong> <br />
Jeśli potrzebne są jedynie np. 2 transformacje, należy ustawić prawdopodobieństwa pozostałych dwóch na zero.</p>
    </blockquote>
  </li>
  <li><strong>Image file name</strong>: nazwa pliku z obrazem fraktala (bez rozszerzenia).</li>
</ul>

<p>Obrazy są zapisywane w formacie <code class="language-plaintext highlighter-rouge">.bmp</code> w katalogu, w którym znajduje się program.</p>

<p>Można poruszać się i przybliżać obraz fraktala w programie za pomocą strzałek i scrolla.</p>

<h2 id="jak-działa-ten-program">Jak działa ten program?</h2>
<p>Wybrana liczba puntków jest jednorodnie rozłożona w kwadracie, po czym są one poddawane algorytmowi IFSP. Każdy piksel posiada gęstość równą liczbie punktów, która w nim wylądowała. Jego jasność jest ustalana na podstawie gęstości - piksele z 0 punktami są czarne, a piksele z największą ich liczbą białe.</p>

<h2 id="przykładowe-obrazy">Przykładowe obrazy</h2>
<p align="center">
<img src="/assets/images/2025-07-31/bazia.jpg" width="600" />
</p>
<p align="center">
<img src="/assets/images/2025-07-31/choinka.jpg" width="600" />
</p>
<p align="center">
<img src="/assets/images/2025-07-31/sierpinsk.jpg" width="600" />
</p>
<p align="center">
<img src="/assets/images/2025-07-31/dragon.jpg" width="600" />
</p>

<h2 id="licencja">Licencja</h2>
<p>Program nie posiada licencji i może być używany w dowolny sposób.</p>]]></content><author><name></name></author><category term="Programowanie" /><summary type="html"><![CDATA[Obraz wygenerowany z użyciem programu]]></summary></entry><entry><title type="html">Mechanika Lagrange’a, część 3: Układy nieswobodne</title><link href="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-3-uk%C5%82ady-nieswobodne" rel="alternate" type="text/html" title="Mechanika Lagrange’a, część 3: Układy nieswobodne" /><published>2025-07-25T00:00:00+02:00</published><updated>2025-07-25T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-3-uk%C5%82ady-nieswobodne</id><content type="html" xml:base="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-3-uk%C5%82ady-nieswobodne"><![CDATA[<h2 id="układ-nieswobodny">Układ nieswobodny</h2>
<p>Do tej pory opisywalśmy ruch cząstki przy założeniu, że jej ruch jest swobodny. Teraz zajmiemy się przypadkiem, gdy jej ruch jest ograniczony <strong>więzami</strong>.</p>

<p>Rozważmy cząstkę poruszającą się w 3 wymiarach, której ruch jest ograniczony do pewnej powierzchni (na przykład kula znajdująca się między dwoma płytkami uniemożliwiającymi jej ruch w kierunku prostopadłym do ich powierzchni). W mechanice Newtona oznacza to, że na kulę działa siła reakcji prostopadła do powierzchni ograniczającej jej ruch, jak zostało pokazane na rysunku. $\hat{T}$ oznacza wektor styczny do kierunku ruchu i zarazem płaszczyzny.</p>

<p align="center">
<img src="/assets/images/2025-07-25/siła_reakcji.svg" width="500" />
</p>

<p>Mimo tego, że cząstka porusza się w przestrzeni 3-wymiarowej, do opisania jej położenia potrzebujemy jedynie 2 współrzędnych $q_1$ i $q_2$ (ponieważ jej ruch jest ograniczony do powierzchni). Spodziewamy się zatem, że jej ruch będą w pełni opisywać równania Lagrange’a
$$ \frac{\partial\mathcal{L}}{\partial q_i}-\frac{d}{dt}\frac{\partial\mathcal{L}}{\partial \dot{q_i}}=0, $$
dla których lagranżjan jest dany wzorem
$$ \mathcal{L}=T-U, $$
gdzie $U$ jest energią potencjalną wszystkich sił (przy założeniu, że da się je zapisać jako jej gradient) <strong>oprócz sił reakcji</strong>. Innymi słowy
$$ \mathbf{F}_{cał.}=\mathbf{F}+\mathbf{F}_R=-\nabla U+\mathbf{F}_R, $$
gdzie $\mathbf{F}_R$ to siła reakcji, a $\mathbf{F}_{cał.}$ to siła całkowita działająca na cząstkę.</p>

<p>Chcielibyśmy udowodnić, że to sformułowanie jest równoważne sformułowaniu newtonowskiemu.</p>

<h3 id="dowód">Dowód</h3>
<p>Rozważmy ruch cząstki w czasie od $t_1$ do $t_2$ po torze $\mathbf{r}$.
Powyższe twierdzenie jest równoważne temu, że wariacja działania wynosi 0:
$$ \delta S=\delta \int_{t_1}^{t_2}\mathcal{L}(\mathbf{r}, \dot{\mathbf{r}}, t)\,dt =0$$
Rozważmy zatem tor $\mathbf{R}=\mathbf{r}+\boldsymbol{\varepsilon}$, gdzie $\boldsymbol{\varepsilon}$ wynosi $\mathbf{0}$ dla $t_1$ i $t_2$ oraz nie wychodzi poza powierzchnię ruchu cząstki (cząstka dalej pozostaje ograniczona). Zostało to zilustrowane na poniższym rysunku, gdzie kolorem białym została oznaczona prawdziwa trajektoria cząstki, a niebieskim $\mathbf{R}$. Ruch cząstki jest ograniczony do zielonej płaszczyzny.</p>

<p align="center">
<img src="/assets/images/2025-07-25/wykres_powierzchnia.svg" width="500" />
</p>

<p>Wariacja działania to wtedy
$$ \delta S=\int_{t_1}^{t_2}\left[\mathcal{L}(\mathbf{R}, \dot{\mathbf{R}}, t)-\mathcal{L}(\mathbf{r}, \dot{\mathbf{r}}, t)\right]\,dt$$
Obliczmy różnicę znajdującą się pod całką:
$$ \mathcal{L}(\mathbf{R}, \dot{\mathbf{R}}, t)-\mathcal{L}(\mathbf{r}, \dot{\mathbf{r}}, t)=T(\dot{\mathbf{R}})-U(\mathbf{R}, t)-T( \dot{\mathbf{r}})+U(\mathbf{r}, t)$$
Wyznaczmy poszczególne wyrazy:
$$ T(\dot{\mathbf{R}})=\frac{1}{2}m\dot{R}^2=\frac{1}{2}m\left(\dot{\mathbf{r}}+\dot{\boldsymbol{\varepsilon}}\right)^2=\frac{1}{2}m\left(\dot{r}^2+2\dot{\mathbf{r}}\cdot\dot{\boldsymbol{\varepsilon}}+\dot{\varepsilon}^2\right)$$
$$ T(\dot{\mathbf{R}})-T( \dot{\mathbf{r}})=\frac{1}{2}m\left(\dot{r}^2+2\dot{\mathbf{r}}\cdot\dot{\boldsymbol{\varepsilon}}+\dot{\varepsilon}^2\right)-\frac{1}{2}m\dot{r}^2=m\dot{\mathbf{r}}\cdot\dot{\boldsymbol{\varepsilon}}+\frac{1}{2}m\dot{\varepsilon}^2$$
Ponieważ $\varepsilon$ oraz $\dot{\varepsilon}$ są małe
$$ T(\dot{\mathbf{R}})-T(\dot{\mathbf{r}})\approx m\dot{\mathbf{r}}\cdot\dot{\boldsymbol{\varepsilon}}.$$
Obliczmy teraz różnicę 
$$ -U(\mathbf{R}, t)+U(\mathbf{r}, t)=-\left[ U(\mathbf{r}+\boldsymbol{\varepsilon}, t)-U(\mathbf{r}, t) \right]\approx-\left[ U(\mathbf{r}, t)+\boldsymbol{\varepsilon}\cdot\nabla U(\mathbf{r}, t)-U(\mathbf{r}, t)\right]=-\boldsymbol{\varepsilon}\cdot\nabla U(\mathbf{r}, t)$$
Wracając, mamy
$$ \mathcal{L}(\mathbf{R}, \dot{\mathbf{R}}, t)-\mathcal{L}(\mathbf{r}, \dot{\mathbf{r}}, t)\approx m\dot{\mathbf{r}}\cdot\dot{\boldsymbol{\varepsilon}}-\boldsymbol{\varepsilon}\cdot\nabla U(\mathbf{r}, t)$$
Wstawmy to do całki:
$$ \delta S=\int_{t_1}^{t_2}\left[ m\dot{\mathbf{r}}\cdot\dot{\boldsymbol{\varepsilon}}-\boldsymbol{\varepsilon}\cdot\nabla U(\mathbf{r}, t) \right]\,dt $$
Aby pozbyć się $\dot{\boldsymbol{\varepsilon}}$, pocałkujmy pierwszy wyraz przez części:
$$ \int_{t_1}^{t_2} m\dot{\mathbf{r}}\cdot\dot{\boldsymbol{\varepsilon}} \,dt =\underbrace{\left[m\dot{\mathbf{r}}\cdot\boldsymbol{\varepsilon} \right]_{t_1}^{t_2}}_{=0} -\int_{t_1}^{t_2} m\ddot{\mathbf{r}}\cdot\boldsymbol{\varepsilon}\,dt, $$
co daje nam 
$$ \delta S=\int_{t_1}^{t_2}\boldsymbol{\varepsilon}\cdot\left[-m\ddot{\mathbf{r}} -\nabla U(\mathbf{r}, t) \right]\,dt. $$
Zauważmy teraz, że $m\ddot{\mathbf{r}}=\mathbf{F}_{cał.}$ oraz $-\nabla U(\mathbf{r}, t)=\mathbf{F}$:
$$ \delta S=\int_{t_1}^{t_2}\boldsymbol{\varepsilon}\cdot\left[-\mathbf{F}_{cał.}+\mathbf{F}\right]\,dt$$
Wiemy, że $-\mathbf{F}_{cał.}+\mathbf{F}=-\mathbf{F}-\mathbf{F}_R+\mathbf{F}=-\mathbf{F}_R$, zatem
$$ \delta S =-\int_{t_1}^{t_2}\boldsymbol{\varepsilon}\cdot\mathbf{F}_R\,dt. $$
Jak wspomnieliśmy wcześniej, siły reakcji są <strong>zawsze prostopadłe</strong> do powierzchni ruchu cząstki, a $\boldsymbol{\varepsilon}$ wybraliśmy takie, aby w tej powierzchni leżało. Oznacza to, że $\boldsymbol{\varepsilon}\cdot\mathbf{F}_R=0$, a co za tym idzie
$$ \delta S = 0, $$
co kończy dowód.</p>

<p>Analogiczny dowód można przeprowadzić dla cząstki ograniczonej do ruchu jedynie po krzywej.</p>

<h2 id="przykład">Przykład</h2>
<p>Rozważmy piłkę toczącą się po równi pochyłej. Jej położenie można jednoznacznie określić za pomocą jednej zmiennej $x$. Jeśli oś $x$ wybierzemy tak, aby przebiegała równolegle do równi oraz $x=0$, gdy piłka jest u podstawy równi, jej energia potencjalna będzie dana wzorem
$$ U=mgh=mgx\sin\theta, $$
gdzie $\theta$ to kąt nachylenia równi (patrz rysunek poniżej).</p>

<p align="center">
<img src="/assets/images/2025-07-25/równia.svg" width="300" />
</p>

<p>W tym przypadku cząstka poruszająca się w 2 wymiarach jest ograniczona do 1 wymiaru poprzez siłę reakcji równi.
Lagranżjan piłki będzie wynosił
$$ \mathcal{L}=\frac{1}{2}m\dot{x}^2-mgx\sin\theta, $$
co po wstawieniu do równania Lagrange’a da nam
$$ m\ddot{x}=-mg\sin\theta. $$</p>

<h2 id="przykład-1">Przykład</h2>
<p>Rozważmy wahadło matematyczne o długości $l$, na którego końcu jest zawieszona masa $m$ o energii potencjalnej $U=-mgy=-mgl\cos{\theta}$ (patrz rysunek).</p>

<p align="center">
<img src="/assets/images/2025-07-25/wahadło.svg" width="600" />
</p>

<p>Masa jest ograniczona siłą reakcji linki i jej ruch można opisać za pomocą tylko zmiennej $\theta$. Lagranżjan tego wahadła to
$$ \mathcal{L}=\frac{1}{2}ml^2\dot{\theta}^2+mgl\cos{\theta}, $$
a wynikające z niego równanie ruchu to
$$ ml^2\ddot{\theta}+mgl\sin{\theta}=0. $$</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Układ nieswobodny Do tej pory opisywalśmy ruch cząstki przy założeniu, że jej ruch jest swobodny. Teraz zajmiemy się przypadkiem, gdy jej ruch jest ograniczony więzami.]]></summary></entry><entry><title type="html">Mechanika Lagrange’a, część 2: Zasada Hamiltona</title><link href="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-2-zasada-hamiltona" rel="alternate" type="text/html" title="Mechanika Lagrange’a, część 2: Zasada Hamiltona" /><published>2025-07-22T00:00:00+02:00</published><updated>2025-07-22T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-2-zasada-hamiltona</id><content type="html" xml:base="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-2-zasada-hamiltona"><![CDATA[<h2 id="zasada-hamiltona">Zasada Hamiltona</h2>
<p>Rozważmy swobodną cząstkę poruszającą się między punktami $1$ i $2$ w czasie od $t_1$ do $t_2$. Droga $\mathbf{r}(t)$, którą wybiera cząstka jest taka, że całka działania
$$ S=\int_{t_1}^{t_2}\mathcal{L}(\mathbf{r}, \dot{\mathbf{r}}, t)\,dt $$
jest minimalna (stacjonarna). $\mathcal{L}$ to <strong>lagranżjan</strong> układu zdefiniowany jako
$$ \mathcal{L}(\mathbf{r}, \dot{\mathbf{r}}, t)=T-U, $$
gdzie $T$ to energia kinetyczna cząstki, a $U$ to jej energia potencjalna.</p>

<h3 id="przykład---cząstka-swobodna-w-przestrzeni-3-wymiarowej">Przykład - cząstka swobodna w przestrzeni 3-wymiarowej</h3>
<p>Rozważmy cząstkę o położeniu $\mathbf{r}=(x,y,z)$ oraz prędkości $\dot{\mathbf{r}}=(\dot{x}, \dot{y}, \dot{z})$. Jej energia potencjalna w danej chwili to $U=mgz$, a energia kinetyczna to $T=\frac{1}{2}m\left( \dot{x}^2+\dot{y}^2+\dot{z}^2 \right)$. Wyznaczmy jej równania ruchu.</p>

<p>Funkcja Lagrange’a (lagranżjan) dla tej cząstki to
$$ \mathcal{L}=\frac{1}{2}m\left( \dot{x}^2+\dot{y}^2+\dot{z}^2 \right)-mgz $$
<a href="https://bwegrzyn0.github.io/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-1-r%C3%B3wnanie-eulera-lagrangea" target="_blank">W poprzednim artykule</a> dowiedzieliśmy się, że jeśli funkcja $\mathcal{L}$ sprawia, że całka jest minimalna, to spełnia ona równanie Eulera-Lagrange’a. W naszym przypadku mamy do czynienia z trzema zmiennymi, $x$, $y$ i $z$, więc potrzebujemy trzech równań:
$$ \frac{\partial \mathcal{L}}{\partial x}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{x}}=0$$
$$ \frac{\partial \mathcal{L}}{\partial y}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{y}}=0$$
$$ \frac{\partial \mathcal{L}}{\partial z}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{z}}=0$$
Obliczmy wszystkie pochodne:
$$ \frac{\partial \mathcal{L}}{\partial x}=\frac{\partial \mathcal{L}}{\partial y}=0 $$
$$ \frac{\partial \mathcal{L}}{\partial z}=mg $$
$$ \frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{x}}=\frac{d}{dt}\left(m\dot{x}\right)=m\ddot{x} $$
i analogicznie dla $y$ i $z$. Po wstawieniu mamy:
$$ m\ddot{x}=0 $$
$$ m\ddot{y}=0 $$
$$ m\ddot{z}=mg $$
Widzimy, że otrzymujemy 3 równania ruchu, takie same jak otrzymalibyśmy w przypadku użycia mechaniki Newtona. Zauważmy również, że pochodna $\mathcal{L}$ po współrzędnej jest równa dokładnie składowej siły działającej na cząstkę, a pochodna po składowej prędkości to składowa pędu:
$$\frac{\partial \mathcal{L}}{\partial x}=F_x$$
$$\frac{\partial \mathcal{L}}{\partial \dot{x}}=p_x$$
i analogicznie dla $y$ i $z$. Możemy wstawić to do równania Lagrange’a i otrzymamy dobrze znany wzór
$$ F_x=\frac{d}{dt}p_x, $$
co pokazuje, że w tym przypadku sformułowanie mechaniki Lagrange’a jest równoważne sformułowaniu Newtona.</p>

<h3 id="przykład---cząstka-poruszająca-się-pod-wpływem-potencjału-centralnego">Przykład - cząstka poruszająca się pod wpływem potencjału centralnego</h3>
<p>Rozważmy cząstkę swobodną o masie $m$ poruszającą się w potencjale $U=-GMm/r$, gdzie $r$ to odległość cząstki od początku układu współrzędnych. W tym przypadku najwygodniej będzie posłużyć się współrzędnymi biegunowymi (nie potrzebujemy wsp. sferycznych, ponieważ wiadomo że ruch będzie ograniczony do płaszczyzny) $r$ i $\theta$. Okazuje się, że mimo tego, że $\theta$ jest kątem, wciąż możemy traktować go jak inne współrzędne, np. $x$. Oznacza to, że 2 równania Lagrange’a, które otrzymamy to
$$ \frac{\partial \mathcal{L}}{\partial r}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{r}}=0$$
$$ \frac{\partial \mathcal{L}}{\partial \theta}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{\theta}}=0$$
Obliczmy lagranżjan. Energia kinetyczna to
$$ T=\frac{1}{2}m\left[\dot{r}^2+(r\dot{\theta})^2\right], $$
a energię potencjalną znamy. Zatem
$$ \mathcal{L}=T-U=\frac{1}{2}m\left[\dot{r}^2+(r\dot{\theta})^2\right]+GMm\frac{1}{r}.$$
Obliczmy pochodne:
$$ \frac{\partial \mathcal{L}}{\partial r}=mr\dot{\theta}^2-GMm\frac{1}{r^2} $$
$$ \frac{\partial \mathcal{L}}{\partial \theta}=0$$
$$ \frac{d}{dt}\frac{\partial \mathcal{L}}{\partial \dot{r}}=m\ddot{r} $$
$$ \frac{d}{dt}\frac{\partial \mathcal{L}}{\partial \dot{\theta}}=mr^2\ddot{\theta} $$
i wstawmy je do naszych równań:
$$ m\ddot{r}=mr\dot{\theta}^2-GMm\frac{1}{r^2} $$
$$ mr^2\ddot{\theta}=0 $$
Otrzymujemy ponownie wyniki zgodne z mechaniką Newtona. Zauważmy, że ponownie 
$$\frac{\partial \mathcal{L}}{\partial r}=F_r, $$
gdzie $F_r$ to suma wszystkich sił radialnych działających na cząstkę. Możemy rozpoznać w niej siłę grawitacji oraz fikcyjną siłę odśrodkową.
$$ \frac{\partial \mathcal{L}}{\partial \dot{r}}=p_r,$$
gdzie $p_r$ to radialna składowa pędu cząstki. W przypadku kąta mamy
$$ \frac{\partial \mathcal{L}}{\partial \theta}=\Gamma, $$
gdzie $\Gamma$ to moment siły działający na cząstkę (w tym przypadku 0) oraz 
$$ \frac{\partial \mathcal{L}}{\partial \dot{\theta}}=L, $$
gdzie $L$ to moment pędu cząstki. Ponownie otrzymujemy dobrze znane równania
$$ F_r =\frac{d}{dt}p_r$$
$$ \Gamma = \frac{d}{dt} L. $$</p>

<p>Poprzednie 2 przykłady pokazały nam, że wielkości $\partial\mathcal{L}/\partial q_i$ oraz $\partial\mathcal{L}/\partial \dot{q}_i$, gdzie $q_i$ to pewna <strong>współrzędna uogólniona</strong> (np. $x$, $r$, $\theta$, $\varphi$) pełnią role kolejno siły oraz pędu. Dlatego są one nazywane <strong>siłą uogólnioną</strong> oraz <strong>pędem uogólnionym</strong>.</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Zasada Hamiltona Rozważmy swobodną cząstkę poruszającą się między punktami $1$ i $2$ w czasie od $t_1$ do $t_2$. Droga $\mathbf{r}(t)$, którą wybiera cząstka jest taka, że całka działania $$ S=\int_{t_1}^{t_2}\mathcal{L}(\mathbf{r}, \dot{\mathbf{r}}, t)\,dt $$ jest minimalna (stacjonarna). $\mathcal{L}$ to lagranżjan układu zdefiniowany jako $$ \mathcal{L}(\mathbf{r}, \dot{\mathbf{r}}, t)=T-U, $$ gdzie $T$ to energia kinetyczna cząstki, a $U$ to jej energia potencjalna.]]></summary></entry><entry><title type="html">Mechanika Lagrange’a, część 1: Równanie Eulera-Lagrange’a</title><link href="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-1-r%C3%B3wnanie-eulera-lagrangea" rel="alternate" type="text/html" title="Mechanika Lagrange’a, część 1: Równanie Eulera-Lagrange’a" /><published>2025-07-21T00:00:00+02:00</published><updated>2025-07-21T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-1-r%C3%B3wnanie-eulera-lagrangea</id><content type="html" xml:base="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-1-r%C3%B3wnanie-eulera-lagrangea"><![CDATA[<h2 id="motywacja">Motywacja</h2>
<p>Rozważmy następujący problem: błonę mydlaną rozpięliśmy między dwoma współosiowymi pierścieniami o promieniach $r_1$ i $r_2$. Wiadomo, że bańka mydlana przyjmuje zawsze taki kształt, aby jej pole powierzchni było jak najmniejsze - ten kształt chcemy znaleźć.</p>

<p>Bańkę mydlaną możemy traktować jak bryłę obrotową opisaną funkcją $f(x)$, przy czym $f(x_1)=r_1$ oraz $f(x_2)=r_2$.</p>
<p align="center">
<img src="/assets/images/2025-07-21/blona_mydlana.svg" width="600" />
</p>

<p>Aby policzyć powierzchnię bryły obrotowej, podzielmy ją na nieskończenie małe okręgi o promieniach $f(x)$ i o środkach na osi $x$. Obwód takiego okręgu to $2\pi f(x)$.</p>
<p align="center">
<img src="/assets/images/2025-07-21/bryla_obrotowa.svg" width="500" />
</p>
<p>Element powierzchni rozciągającej się między dwoma bliskimi okręgami to $2\pi f(x)\,dl$. Jak widać na rysunku, $dl=\sqrt{dx^2+(f’(x)\,dx)^2}=\sqrt{1+f’(x)^2}\,dx$. Zatem element powierzchni to $dS=2\pi f(x)\sqrt{1+f’(x)^2}\,dx$. Całkowita powierzchnia takiej bryły to wtedy
$$ S=2\pi\int_{x_1}^{x_2}f(x)\sqrt{1+f’(x)^2}\,dx.$$
Dążymy do zminimalizowania tej całki.</p>

<h2 id="wyprowadzenie-równania-eulera-lagrangea">Wyprowadzenie równania Eulera-Lagrange’a</h2>
<p>Rozważmy ogólniejszy przypadek. Chcemy zminimalizować całkę
$$ S=\int_{x_1}^{x_2}f(Y(x), Y’(x), x)\,dx. $$</p>

<p>Niech $y(x)$ będzie funkcją minimalizującą całkę $S$. Rozważmy funkcję $Y(x)=y(x)+\alpha \eta(x)$, gdzie $\eta(x)$ to dowolna funkcja, która spełnia warunek $\eta(x_1)=\eta(x_2)=0$. Wtedy $Y(x)$ spełnia te same warunki brzegowe co $y(x)$, lecz jest tą ,,mniej optymalną’’, w przypadku błony mydlanej powierzchnią między $x_1$ a $x_2$, czyli powierzchnia dla niej będzie nieco większa niż dla $y(x)$.</p>

<p>Spodziewamy się, że dla małych wartości $\alpha$, czyli małych odchyleń od optymalnej powierzchni, całka $S$ nie będzie ulegać zmianie (podobnie jest w przypadku zwykłych funkcji - gdy $f(x)$ ma minimum w $x_0$, $f’(x_0)=0$. Oznacza to, że w przybliżeniu dla małych $\varepsilon$ zachodzi $f(x_0+\varepsilon)-f(x_0)=f’(x_0)\varepsilon=0$). Innymi słowy
$$ \frac{\partial S}{\partial \alpha}=0. $$
Obliczmy tę pochodną:
$$ \frac{\partial S}{\partial \alpha}=\int_{x_1}^{x_2}\frac{\partial f}{\partial \alpha}\,dx$$
Z reguły łańcuchowej dla wielu zmiennych:
$$ \frac{\partial f}{\partial \alpha}=\frac{\partial f}{\partial Y}\frac{\partial Y}{\partial \alpha}+\frac{\partial f}{\partial Y’}\frac{\partial Y’}{\partial \alpha}+\frac{\partial f}{\partial x}\frac{\partial x}{\partial \alpha}   $$
Łatwo obliczyć, że $\partial Y/\partial \alpha=\eta(x)$, $\partial Y’/\partial \alpha=\eta’(x)$ oraz $\partial x/\partial\alpha=0$. Daje nam to
$$ \frac{\partial S}{\partial \alpha}=\int_{x_1}^{x_2}\left[\frac{\partial f}{\partial Y}\eta(x)+\frac{\partial f}{\partial Y’}\eta’(x)\right]\,dx $$
Aby zamienić $\eta’(x)$ na $\eta(x)$, pocałkujmy przez części:
$$ \int_{x_1}^{x_2}\frac{\partial f}{\partial Y’}\eta’(x)\,dx = \left[\eta(x)\frac{\partial f}{\partial Y’}\right]_{x_1}^{x_2}- \int_{x_1}^{x_2} \eta(x) \frac{d}{dx} \frac{\partial f}{\partial Y’}\,dx$$
Zauważmy, że ponieważ $\eta(x_1)=\eta(x_2)=0$, pierwszy wyraz z prawej strony się zeruje. To pozostawia nas z 
$$ \frac{\partial S}{\partial\alpha}=0=\int_{x_1}^{x_2}\eta(x)\left[ \frac{\partial f}{\partial Y}-\frac{d}{dx}\frac{\partial f}{\partial Y’} \right]\,dx$$
Skoro $\eta(x)$ to dowolna funkcja, wybierzmy $\eta(x)$ takie, że wyrażenie podcałkowe jest zawsze nieujemne. Skoro całka z nieujemnego wyrażenia jest równa $0$, to wyrażenie podcałkowe wynosi 0. Ponieważ $\eta(x)\neq 0$, 
$$ \frac{\partial f}{\partial y}-\frac{d}{dx}\frac{\partial f}{\partial y’} =0,$$
gdzie $Y$ zamieniłem na $y$, ponieważ jeżeli $Y$ spełnia powyższe równanie, jest ono ,,optymalną’’ funkcją. Jest to <strong>równanie Eulera-Lagrange’a</strong>.</p>

<h2 id="problem-błony-mydlanej">Problem błony mydlanej</h2>
<p>Powróćmy do wcześniejszego problemu. Doszliśmy do wniosku, że należy znaleźć funkcję $f(x)$, która minimalizuje całkę
$$ S=2\pi\int_{x_1}^{x_2}f(x)\sqrt{1+f’(x)^2}\,dx.$$
Niech $F(f(x), f’(x))=f(x)\sqrt{1+f’(x)^2}$. Wtedy równanie Eulera-Lagrange’a przyjmuje postać
$$ \frac{\partial F}{\partial f}-\frac{d}{dx}\frac{\partial F}{\partial f’} =0 $$</p>

<p>Zauważmy jednak, że $F(f(x), f’(x))$ nie zależy w jawny sposób od $x$. Pomnóżmy powyższe równanie przez $df/dx$:
$$ \frac{\partial F}{\partial f}\frac{df}{dx}-f’\frac{d}{dx}\frac{\partial F}{\partial f’}=0$$
Możemy obliczyć pierwszy wyraz po lewej stronie:
$$ \frac{\partial F}{\partial f}\frac{df}{dx}=\frac{dF}{dx}-\frac{\partial F}{\partial f’}\frac{df’}{dx}$$
i wstawić go spowrotem:
$$ \frac{dF}{dx}-\frac{\partial F}{\partial f’}\frac{df’}{dx}-f’\frac{d}{dx}\frac{\partial F}{\partial f’}=0 $$
Nietrudno zauważyć, że
$$-\frac{\partial F}{\partial f’}\frac{df’}{dx}-f’\frac{d}{dx}\frac{\partial F}{\partial f’}=-\frac{d}{dx}\left[f’\frac{\partial F}{\partial f’}\right] $$
czyli
$$  \frac{dF}{dx}-\frac{d}{dx}\left[f’\frac{\partial F}{\partial f’}\right]=0 $$
$$ \frac{d}{dx}\left[F-f’\frac{\partial F}{\partial f’}\right]=0 $$
$$ F-f’\frac{\partial F}{\partial f’}=const. $$</p>

<p>Ten rezultat możemy uogólnić. Jeśli $f(y(x), y’(x))$ nie zależy jawnie od $x$, to równanie Eulera-Lagrange’a sprowadza się do <strong>całki pierwszej</strong>:
$$ f-y’\frac{\partial f}{\partial y’}=const. $$</p>

<p>Wracając do problemu bańki mydlanej, mamy
$$ \frac{\partial F}{\partial f’}=f\frac{f’}{\sqrt{1+f’^2}} $$
Wstawmy to do całki pierwszej:
$$ f\sqrt{1+f’^2}-\frac{ff’^2}{\sqrt{1+f’^2}} = C $$
$$ f(1+f’^2)-ff’^2=C\sqrt{1+f’^2} $$
Dostajemy równanie różniczkowe 1 rzędu, które można rozwiązać za pomocą separacji zmiennych:
$$ f=C\sqrt{1+f’^2} $$
$$ 1+f’^2=Cf^2 $$
$$ \frac{df}{dx}=\sqrt{Cf^2-1} $$
$$ x+C_1=\int \frac{df}{\sqrt{C_2f^2-1} }$$
Całka po prawej stronie sprowadza się do $\frac{1}{C}\cosh^{-1}\left(Cf\right)$, a stąd
$$ f(x)=\frac{1}{C_1} \cosh (C_1 x+C_2), $$
gdzie $C_1$ i $C_2$ to pewne stałe.</p>

<h2 id="przypadek-wielu-zmiennych">Przypadek wielu zmiennych</h2>
<p>W przypadku, gdy $f=f(y_1, y_1’, y_2, y_2’, x)$, zapisujemy <strong>2 równania Eulera-Lagrange’a</strong>, oddzielnie dla każdej zmiennej.
Jest tak, ponieważ jeśli rozważymy 2 funkcje 
$$ Y_1=y_1+\alpha\eta_1 $$
oraz
$$ Y_2=y_2+\beta\eta_2 $$
gdzie $\eta_1$ i $\eta_2$ spełniają takie warunki, jak wcześniejsze $\eta$, dostajemy 2 równania
$$ \frac{\partial S}{\partial \alpha}=0 $$
oraz 
$$ \frac{\partial S}{\partial \beta}=0. $$
W obu przypadkach zniknie albo $Y_1$ albo $Y_2$, co da nam 2 równania:
$$ \frac{\partial f}{\partial y_1}-\frac{d}{dx}\frac{\partial f}{\partial y_1’}=0 $$
$$ \frac{\partial f}{\partial y_2}-\frac{d}{dx}\frac{\partial f}{\partial y_2’}=0. $$
Wynik ten łatwo uogólnia się na większą liczbę zmiennych.</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Motywacja Rozważmy następujący problem: błonę mydlaną rozpięliśmy między dwoma współosiowymi pierścieniami o promieniach $r_1$ i $r_2$. Wiadomo, że bańka mydlana przyjmuje zawsze taki kształt, aby jej pole powierzchni było jak najmniejsze - ten kształt chcemy znaleźć.]]></summary></entry><entry><title type="html">Tworzenie prostej symulacji grawitacji w C++, część 2: Rysowanie kół, planety</title><link href="http://localhost:4000/programowanie/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-2-rysowanie-k%C3%B3%C5%82-planety" rel="alternate" type="text/html" title="Tworzenie prostej symulacji grawitacji w C++, część 2: Rysowanie kół, planety" /><published>2025-07-13T00:00:00+02:00</published><updated>2025-07-13T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-2-rysowanie-k%C3%B3%C5%82-planety</id><content type="html" xml:base="http://localhost:4000/programowanie/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-2-rysowanie-k%C3%B3%C5%82-planety"><![CDATA[<h2 id="rysowanie-kół">Rysowanie kół</h2>
<p>Aby obserwować interakcję grawitacyjną, potrzebujemy obiekty, które będą w taki sposób oddziaływać. W tej symulacji będą one nazywane planetami, chociaż nie będą miały ściśle określonego przedziału na masę, gęstość i rozmiary. Będziemy je traktować jak kule, czyli w tym wypadku tak samo, jak masy punktowe. Aby reprezentować je na ekranie, będzie konieczna możliwość rysowania kół. Niestety SDL nie posiada funkcji wykonującej takie zadanie, więc trzeba ją stworzyć samodzielnie.</p>

<p>Wydajnym algorytmem do rysowania kół i okręgów jest <a href="https://en.wikipedia.org/wiki/Midpoint_circle_algorithm" target="_blank">algorytm midpoint</a>. Jego implementację dla SDL znalazłem <a href="https://gist.github.com/Gumichan01/332c26f6197a432db91cc4327fcabb1c" target="_blank">tutaj</a>.</p>

<p>W funkcji <code class="language-plaintext highlighter-rouge">draw()</code> przeniesionej do osobnego pliku dodałem następujące linijki rysujące okrąg i koło:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SDL_RenderDrawCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="n">SDL_RenderFillCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div></div>
<p>Rezultat jest następujący:</p>
<p align="center">
<img src="/assets/images/2025-07-13/okrag-i-kolo-test.png" width="500" />
</p>

<h2 id="planety">Planety</h2>
<h3 id="obiekt-planeta">Obiekt planeta</h3>
<p>W pliku <code class="language-plaintext highlighter-rouge">planet.h</code> utworzyłem klasę <code class="language-plaintext highlighter-rouge">Planet</code>, a w niej potrzebne zmienne i funkcje.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef PLANET_H
#define PLANET_H
</span><span class="k">class</span> <span class="nc">Planet</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="c1">// położenie planety</span>
        <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
        <span class="c1">// prędkość planety</span>
        <span class="kt">float</span> <span class="n">v_x</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">v_y</span><span class="p">;</span>
        <span class="c1">// masa planety</span>
        <span class="kt">float</span> <span class="n">mass</span><span class="p">;</span>
        <span class="c1">// gęstość planety</span>
        <span class="kt">float</span> <span class="n">density</span><span class="p">;</span>
        <span class="c1">// promień planety </span>
        <span class="kt">float</span> <span class="n">radius</span><span class="p">;</span>
        <span class="c1">// przyspieszenie planety</span>
        <span class="kt">float</span> <span class="n">a_x</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">a_y</span><span class="p">;</span>
        <span class="c1">// indentyfikator</span>
        <span class="kt">float</span> <span class="n">ID</span><span class="p">;</span>
        <span class="c1">// konstruktor</span>
        <span class="n">Planet</span><span class="p">(</span><span class="kt">float</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_v_x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_v_y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_mass</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_density</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_ID</span><span class="p">);</span>
        <span class="c1">// funkcja aktualizująca położenie planety</span>
        <span class="kt">void</span> <span class="n">updatePos</span><span class="p">();</span>
<span class="p">};</span>
<span class="cp">#endif
</span></code></pre></div></div>
<p>Identyfikator będzie potrzebny do obliczania przyspieszenia.</p>

<p>Następnie w pliku <code class="language-plaintext highlighter-rouge">planet.cpp</code> utworzyłem konstruktor, w którym obliczam promień na podstawie masy i gęstości ze wzoru
$$R = \left(\frac{3M}{4\pi\rho}\right)^{1/3}$$</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Planet</span><span class="o">::</span><span class="n">Planet</span><span class="p">(</span><span class="kt">float</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_v_x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_v_y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_mass</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_density</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_ID</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// przyporządkowujemy zmienne lokalne przekazane do konstruktora zmiennym globalnym 		</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_x</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">_y</span><span class="p">;</span>
    <span class="n">v_x</span> <span class="o">=</span> <span class="n">_v_x</span><span class="p">;</span>
    <span class="n">v_y</span> <span class="o">=</span> <span class="n">_v_y</span><span class="p">;</span>
    <span class="n">mass</span> <span class="o">=</span> <span class="n">_mass</span><span class="p">;</span>
    <span class="n">density</span> <span class="o">=</span> <span class="n">_density</span><span class="p">;</span>
    <span class="n">ID</span> <span class="o">=</span> <span class="n">_ID</span><span class="p">;</span> 
    <span class="n">a_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">a_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// R = [3M/(4*PI*rho)]^(1/3) dla jednorodnej kuli</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">pow</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="p">(</span><span class="mf">3.0f</span><span class="o">*</span><span class="n">mass</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0f</span><span class="o">*</span><span class="mf">3.1415f</span><span class="o">*</span><span class="n">density</span><span class="p">)),</span> <span class="mx">0.333d</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>W funkcji <code class="language-plaintext highlighter-rouge">updatePos()</code> zaimplementowałem proste obliczanie kolejnych położeń i prędkości planety za pomocą algorytmu Eulera.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Planet</span><span class="o">::</span><span class="n">updatePos</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Planet</span><span class="o">&gt;</span> <span class="n">planets</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// OBLICZANIE POŁOŻENIA</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">v_x</span> <span class="o">*</span> <span class="n">dT</span><span class="p">;</span>
        <span class="c1">// dT to krok czasowy zdefiniowany w pliku main.h</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="n">v_y</span> <span class="o">*</span> <span class="n">dT</span><span class="p">;</span>

        <span class="c1">// OBLICZANIE PRĘDKOŚCI</span>
        <span class="c1">// musimy zresetować przyspieszenie, aby obliczyć je na nowo</span>
        <span class="n">a_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">a_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// obliczanie przyspieszenia ...</span>

        <span class="c1">// aktualizujemy prędkość</span>
        <span class="n">v_x</span> <span class="o">+=</span> <span class="n">a_x</span> <span class="o">*</span> <span class="n">dT</span><span class="p">;</span>
        <span class="n">v_y</span> <span class="o">+=</span> <span class="n">a_y</span> <span class="o">*</span> <span class="n">dT</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>$dT$ to pewien krok czasowy ustalony w pliku <code class="language-plaintext highlighter-rouge">main.h</code>. W przyszłości zostanie zaimplementowany algorytm Rungego-Kutty.</p>

<p>Ponieważ krok czasowy jest stały, w przypadku spowolnienia działania programu, zostanie również spowolniona symulacja. Rozważmy to na przykładzie. Załóżmy że program działa z szybkością 60 klatek na sekundę. Wtedy w ciągu sekundy przy kroku czasowym równym $1/60\text{s}$ symulacja postąpi o $1\text{s}$. Jeśli program będzie działał z szybkością 30 klatek na sekundę, aby w tym samym czasie symulacja postąpiła o czas $1\text{s}$, krok czasowy musiałby być 2 razy dłuższy.
Zostanie to w przyszłości naprawione implementując inną postać pętli programu.</p>

<h3 id="zarządzanie-planetami">Zarządzanie planetami</h3>
<p>Aby sprawnie zarządzać wszystkimi obiektami utworzyłem plik <code class="language-plaintext highlighter-rouge">handler.cpp</code>, którego zadaniem będzie aktualizowanie wszystkich planet. W nim utworzyłem wektor ze wszystkimi planetami i funkcję, która będzie je aktualizować.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">updatePlanets</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">planets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">updatePos</span><span class="p">();</span>	
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Warto zauważyć, że nie zadziała tutaj pętla for each, ponieważ tworzy ona nowe obiekty planet i aktualizuje parametry tych nowych, a nie już istniejących obiektów.</p>

<p>W pliku <code class="language-plaintext highlighter-rouge">main.cpp</code> utworzyłem funkcję:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setupEnvironment</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">planets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="n">Planet</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">5.47</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="n">planets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="n">Planet</span><span class="p">(</span><span class="mi">595</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="n">planets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="n">Planet</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.033</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>oraz dodałem <code class="language-plaintext highlighter-rouge">updatePlanets()</code> z <code class="language-plaintext highlighter-rouge">handler.cpp</code> do pętli.</p>

<p>Należy pamiętać, aby wyświetlać planety na ekranie, dlatego zmodyfikowałem funkcję <code class="language-plaintext highlighter-rouge">draw()</code> w następujący sposób:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">SDL_Renderer</span><span class="o">*</span> <span class="n">renderer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ustal kolor tła i je zapełń</span>
    <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
    <span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>

    <span class="c1">// renderujemy po kolei wszystkie planety</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">planets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
        <span class="n">SDL_RenderFillCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">100</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// wyświetl to, co zostało narysowane </span>
    <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="interakcja-grawitacyjna">Interakcja grawitacyjna</h3>
<p>Potrzebujemy w funkcji <code class="language-plaintext highlighter-rouge">updatePlanets()</code> dostęp do wektora <code class="language-plaintext highlighter-rouge">planets</code>, więc będzie on przekazywany jako argument tej funkcji. Następnie utwórzmy w niej pętlę sumującą przyspieszenia pochodzące od wszystkich innych planet, aby obliczyć siłę wypadkową. Oczywiście musimy sumować rzuty przyspieszeń na poszczególne osie.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">planets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">ID</span> <span class="o">!=</span> <span class="n">ID</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// nie chcemy żeby planeta przyciągała sama siebie</span>
        <span class="c1">// obliczamy r^2</span>
        <span class="kt">float</span> <span class="n">distance_squared</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">y</span><span class="p">);</span>
        <span class="c1">// obliczamy wartość przyspieszenia</span>
        <span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">*</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">mass</span><span class="o">/</span><span class="n">distance_squared</span><span class="p">;</span>
        <span class="c1">// obliczamy wartość sinusa i cosinusa kąta między planetami</span>
        <span class="kt">float</span> <span class="n">cos</span> <span class="o">=</span> <span class="p">(</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">x</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">pow</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">distance_squared</span><span class="p">,</span> <span class="mx">0.5d</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">y</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">pow</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">distance_squared</span><span class="p">,</span> <span class="mx">0.5d</span><span class="p">);</span>
        <span class="c1">// dodajemy składowe przyspieszenia</span>
        <span class="n">a_x</span> <span class="o">+=</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">;</span>
        <span class="n">a_y</span> <span class="o">+=</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="poruszanie-kamerą">Poruszanie kamerą</h2>
<p>Planety mogą szybko uciec z pola widzenia, dlatego ważna jest możliwość poruszania kamerą.</p>

<p>Utworzyłem tablicę boolów <code class="language-plaintext highlighter-rouge">keysDown</code> o 4 elementach, które opisują stan wciśnięcia strzałek na klawiaturze. Są one ustalane w funkcji <code class="language-plaintext highlighter-rouge">handleEvents()</code> w <code class="language-plaintext highlighter-rouge">main.cpp</code>. Na ich podstawie mogę zmieniać aktualną prędkość i położenie kamery:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">updateCam</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ustawiamy prędkość kamery na postawie wciśniętych klawiszy</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">keysDown</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cam_vy</span> <span class="o">=</span> <span class="o">-</span><span class="n">cam_v</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">keysDown</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cam_vy</span> <span class="o">=</span> <span class="n">cam_v</span><span class="p">;</span>
    <span class="k">else</span> 
        <span class="n">cam_vy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">keysDown</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">cam_vx</span> <span class="o">=</span> <span class="n">cam_v</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">keysDown</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">cam_vx</span> <span class="o">=</span> <span class="o">-</span><span class="n">cam_v</span><span class="p">;</span>
    <span class="k">else</span> 
        <span class="n">cam_vx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// aktualizujemy położenie kamery</span>
    <span class="n">cam_x</span> <span class="o">+=</span> <span class="n">cam_vx</span><span class="p">;</span>
    <span class="n">cam_y</span> <span class="o">+=</span> <span class="n">cam_vy</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">cam_v</code> to pewna odgórnie ustalona (później dostępna do regulacji dla użytkownika) prędkość kamery.
Aby zmiana położenia kamery miała efekt, jej położenie musimy odjąć od położenia planet:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SDL_RenderFillCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">x</span> <span class="o">-</span> <span class="n">cam_x</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">y</span> <span class="o">-</span> <span class="n">cam_y</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">100</span><span class="p">));</span>
</code></pre></div></div>
<p>Dlaczego tak jest? Załóżmy, że planeta jest w pozycji $(200, 200)$, a kamera w pozycji $(100, 100)$. Oznacza to, że planeta jest o $100$ pikseli niżej i o $100$ pikseli na prawo od kamery. Położenie planety na ekranie powinno zatem wynosić $(100, 100)$, a więc $(200, 200)-(100,100)$.</p>

<p>W chwili obecnej program prezentuje się następująco:</p>
<p align="center">
<img src="/assets/images/2025-07-13/dzialanie-programu.gif" width="500" />
</p>

<p>W następnej części zostanie zaimplementowana ulepszona pętla programu oraz algorytm Rungego-Kutty do obliczania trajektorii planet. Kod źródłowy projektu jest dostępny na <a href="https://github.com/bwegrzyn0/grav-sim" target="_blank">GitHub</a>.</p>]]></content><author><name></name></author><category term="Programowanie" /><summary type="html"><![CDATA[Rysowanie kół Aby obserwować interakcję grawitacyjną, potrzebujemy obiekty, które będą w taki sposób oddziaływać. W tej symulacji będą one nazywane planetami, chociaż nie będą miały ściśle określonego przedziału na masę, gęstość i rozmiary. Będziemy je traktować jak kule, czyli w tym wypadku tak samo, jak masy punktowe. Aby reprezentować je na ekranie, będzie konieczna możliwość rysowania kół. Niestety SDL nie posiada funkcji wykonującej takie zadanie, więc trzeba ją stworzyć samodzielnie.]]></summary></entry><entry><title type="html">Tworzenie prostej symulacji grawitacji w C++, część 1: SDL2</title><link href="http://localhost:4000/programowanie/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-1-sdl2" rel="alternate" type="text/html" title="Tworzenie prostej symulacji grawitacji w C++, część 1: SDL2" /><published>2025-07-06T00:00:00+02:00</published><updated>2025-07-06T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-1-sdl2</id><content type="html" xml:base="http://localhost:4000/programowanie/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-1-sdl2"><![CDATA[<h2 id="cel-projektu">Cel projektu</h2>
<p>Celem tego projektu jest stworzenie programu w C++, który będzie pozwalał użytkownikowi:</p>
<ul>
  <li>dodawać do sceny ciała niebieskie, które będą oddziaływać ze sobą grawitacyjnie</li>
  <li>modyfikować ich parametry, takie jak masa, prędkość, położenie, jasność itd. za pomocą prostego interfejsu</li>
  <li>pauzować, przyspieszać, cofać, resetować symulację</li>
  <li>poruszać się kamerą po scenie za pomocą myszki, przybliżać i oddalać widok</li>
  <li>wykreślać i przewidywać trajektorie obiektów</li>
  <li>ustalać punkt odniesienia dla trajektorii</li>
  <li>zablokować widok na jednym obiekcie.</li>
</ul>

<p>Program ma spełniać również następujące założenia:</p>
<ul>
  <li>ruch planet ma być dokładnie obliczany za pomocą algorytmu Rungego-Kutty (opisanego w <a href="/programowanie/numeryczne-rozwiązywanie-równań-różniczkowych-2-rzędu-metodą-rungego-kutty" target="_blank">tym</a> artykule)</li>
  <li>program ma być zoptymalizowany</li>
  <li>ruch będzie odbywał się w jednej płaszczyźnie i przedstawiany będzie widok z góry</li>
  <li>oświetlenie planet, zaćmienia (gdy jedna planeta przechodzi za drugą)</li>
  <li>planety będą przedstawiane jako koła o różnych kolorach</li>
  <li>anti-aliasing planet</li>
  <li>zarządzanie obiektami w kodzie powinno być łatwe i uporządkowane.</li>
</ul>

<h2 id="kod-źródłowy">Kod źródłowy</h2>
<p>Kod źródłowy projektu jest dostępny w <a href="https://github.com/bwegrzyn0/grav-sim" target="_blank">repozytorium GitHub</a>.</p>

<h2 id="wyświetlanie-okna---sdl2">Wyświetlanie okna - SDL2</h2>
<p>Do wyświetlania okna i rysowania na nim w tym projekcie użyłem bibliotekę <a href="https://www.libsdl.org/" target="_blank">SDL2</a>. Dobry poradnik, jak ją używać, można znaleźć <a href="https://lazyfoo.net/tutorials/SDL/index.php" target="_blank">tutaj</a>.</p>

<h3 id="inicjalizacja-sdl">Inicjalizacja SDL</h3>
<p>W pliku <code class="language-plaintext highlighter-rouge">main.cpp</code> dodałem bibliotekę SDL2:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;SDL2/SDL.h&gt;</span><span class="cp">
</span></code></pre></div></div>
<p>a następnie utworzyłem zmienne i obiekty:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// wymiary okna</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>

<span class="c1">// okno</span>
<span class="n">SDL_Window</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="c1">// renderer</span>
<span class="n">SDL_Renderer</span><span class="o">*</span> <span class="n">renderer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>
<p>Obiekt <code class="language-plaintext highlighter-rouge">renderer</code> będzie odpowiedzialny za rysowanie pikseli w oknie <code class="language-plaintext highlighter-rouge">window</code>. Stworzyłem funkcję inicjalizującą SDL:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja odpowiadająca za inicjalizację SDL</span>
<span class="kt">bool</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="c1">// inicjalizuj SDL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Could not init SDL: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
		<span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// utwórz okno</span>
		<span class="n">window</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span><span class="s">"grav-sim"</span><span class="p">,</span> <span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span> <span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">SDL_WINDOW_SHOWN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"Could not create window: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
			<span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// stwórz renderer</span>
			<span class="n">renderer</span> <span class="o">=</span> <span class="n">SDL_CreateRenderer</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">SDL_RENDERER_ACCELERATED</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">renderer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"Could not create renderer: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
				<span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Jeśli inicjalizacja nie przebiegnie pomyślnie, funkcja zwróci <code class="language-plaintext highlighter-rouge">false</code>. Potrzebna jest również funkcja “sprzątająca” po wszystkim:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja odpowiadająca za "posprzątanie" po wszystkim</span>
<span class="kt">void</span> <span class="nf">close</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// zniszcz okno, zwolnij miejsce w pamięci, zamknij SDL</span>
	<span class="n">SDL_DestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
	<span class="n">window</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">SDL_Quit</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="rejestrowanie-wejścia-od-użytkownika">Rejestrowanie wejścia od użytkownika</h3>
<p>W tym celu utworzyłem obiekt <code class="language-plaintext highlighter-rouge">SDL_Event</code>, który będzie wykrywał zdarzenia, takie jak wciśnięcie klawiatury, myszki itd. oraz funkcję, która na podstawie wykrytego zdarzenia wypisze informację do konsoli:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">SDL_Event</span> <span class="n">event</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">handleEvents</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">SDL_PollEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// funkcja sprawdzająca zdarzenia</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// typ zdarzenia</span>
            <span class="k">case</span> <span class="n">SDL_KEYDOWN</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Key press</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">// wciśnięcie klawisza na klawiaturze</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">SDL_KEYUP</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Key up</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">// puszczenie klawisza na klawiaturze</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">SDL_QUIT</span><span class="p">:</span>
                <span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// zamknięcie okna</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Quitting</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="nl">default:</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Zmienna <code class="language-plaintext highlighter-rouge">running</code> mówi, czy program jest uruchomiony. Przyda się ona w jednym z kolejnych kroków.</p>

<h3 id="rysowanie">Rysowanie</h3>
<p>Utworzyłem funkcję, która będzie odpowiedzialna za rysowanie na ekranie. Dodałem w niej również rysowanie białego prostokąta:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span> <span class="c1">// ustawiamy kolor tła (RGBA)</span>
	<span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span> <span class="c1">// zapełniamy tło</span>

	<span class="n">SDL_Rect</span> <span class="n">rect</span><span class="p">;</span> <span class="c1">// tworzymy nowy obiekt typu prostokąt</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// ustalamy jego położenie i rozmiary</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// ustawiamy kolor prostokąta</span>
	<span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="p">);</span> <span class="c1">// rysujemy wypełniony prostokąt</span>

	<span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span> <span class="c1">// wyświetlamy obraz na ekranie</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pętla-programu">Pętla programu</h3>
<p>Utworzyłem funkcję zawierającą główną pętlę programu:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handleEvents</span><span class="p">();</span>
		<span class="n">draw</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Na razie kod jest uruchamiany w pętli while, czyli jak najszybciej jest to możliwe. Jest to oczywiście nieopłacalne i niestabilne. Zostanie to naprawione później.</p>

<p>Tak wygląda moja funkcja <code class="language-plaintext highlighter-rouge">main()</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">loop</span><span class="p">();</span>
	<span class="n">close</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="co-dalej">Co dalej?</h2>
<p>Powyższy program wyświetla okno, a w nim biały prostokąt na czerwonym tle. W następnej części opiszę proces rysowania kół i okręgów za pomocą algorytmu midpoint oraz to, jak dodałem planety.</p>]]></content><author><name></name></author><category term="Programowanie" /><summary type="html"><![CDATA[Cel projektu Celem tego projektu jest stworzenie programu w C++, który będzie pozwalał użytkownikowi: dodawać do sceny ciała niebieskie, które będą oddziaływać ze sobą grawitacyjnie modyfikować ich parametry, takie jak masa, prędkość, położenie, jasność itd. za pomocą prostego interfejsu pauzować, przyspieszać, cofać, resetować symulację poruszać się kamerą po scenie za pomocą myszki, przybliżać i oddalać widok wykreślać i przewidywać trajektorie obiektów ustalać punkt odniesienia dla trajektorii zablokować widok na jednym obiekcie.]]></summary></entry><entry><title type="html">Numeryczne rozwiązywanie równań różniczkowych 2 rzędu za pomocą algorytmu Rungego-Kutty</title><link href="http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty" rel="alternate" type="text/html" title="Numeryczne rozwiązywanie równań różniczkowych 2 rzędu za pomocą algorytmu Rungego-Kutty" /><published>2025-06-30T00:00:00+02:00</published><updated>2025-06-30T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty</id><content type="html" xml:base="http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty"><![CDATA[<h2 id="algorytm-rungego-kutty">Algorytm Rungego-Kutty</h2>
<p>Mamy dane równanie różniczkowe 1 rzędu w postaci
$$ \frac{dy}{dx}=f(x,y). $$
Najprostszą metodą, aby rozwiązać tego typu równanie numerycznie jest metoda Eulera. Pochodną możemy przybliżyć jako
$$ \frac{dy}{dx}\approx\frac{y(x+\Delta x)-y(x)}{\Delta x}, $$
a stąd
$$ y(x+\Delta x)\approx y(x)+\Delta x f(x,y). $$
Metoda ta jest bardzo niedokładna szczególnie dla rozwiązań oscylujących. Jest ona również nazywana algorytmem Rungego-Kutty 1 rzędu.</p>

<p>O wiele lepsze przybliżenie daje algorytm Rungego-Kutty 4 rzędu. W pierwszej kolejności należy obliczyć 4 wielkości:
$$ k_1=f(x,y) $$
$$ k_2=f(x+\frac{\Delta x}{2}, y+\frac{\Delta x}{2}k_1) $$
$$ k_3=f(x+\frac{\Delta x}{2}, y+\frac{\Delta x}{2}k_2) $$
$$ k_4=f(x+\Delta x, y+\Delta x\,k_3), $$
a następnie możemy obliczyć wartość szukanej funkcji w kolejnym kroku:
$$ y(x+\Delta x)\approx y(x)+\frac{\Delta x}{6}(k_1+2k_2+2k_3+k_4). $$</p>
<h3 id="przykład">Przykład</h3>
<p>Rozważmy równanie nieliniowe
$$ \frac{dy}{dx}=y\cos x$$
z warunkiem początkowym $ y(0)=1 $. Łatwo jest sprawdzić, że jego rozwiązaniem jest $ y=e^{\sin x}$.</p>

<p>Program rozwiązujący to równanie numerycznie został napisany w C++.</p>

<p>W pierwszej kolejności definiujemy zmienne i warunki początkowe:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// ustawiamy y na wartość początkową</span>
<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// ustawiamy x na wartość początkową</span>
<span class="kt">float</span> <span class="n">x_max</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> <span class="c1">// końcowa wartość x</span>
<span class="kt">float</span> <span class="n">step</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// krok - Delta x</span>
</code></pre></div></div>

<p>Następnie zdefiniujmy naszą funkcję $f(x,y)$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">dy_dx</span><span class="p">(</span><span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Teraz musimy wykonać <code class="language-plaintext highlighter-rouge">(x_max-x_min)/step</code> kroków, a w każdym z nich wykonać procedurę opisaną na początku artykułu:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">float</span> <span class="n">k_1</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_2</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">k_1</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_3</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_4</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">*</span><span class="n">k_3</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="p">);</span>

		<span class="n">x</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span> <span class="c1">// zwiększamy x o jeden krok</span>
		<span class="n">y</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3</span><span class="o">+</span><span class="n">k_4</span><span class="p">);</span> <span class="c1">// obliczamy y(x+Delta x)</span>
		<span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// zapisujemy wynik do pliku </span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wyniki zapisałem do pliku <code class="language-plaintext highlighter-rouge">.csv</code>, a następnie naniosłem w pythonie na widoczny poniżej wykres:</p>

<p align="center">
<img src="/assets/images/2025-06-30/przyklad1.svg" width="500" />
</p>
<p>Czerwona linia przedstawia rozwiązanie analityczne, a niebieskie krzyżyki rozwiązanie numeryczne. Widzimy, że algorytm Rungego-Kutty 4 rzędu nawet przy dużych wartościach $ \Delta x $ daje bardzo dobre rezultaty.</p>

<h2 id="równanie-różniczkowe-2-rzędu-jako-układ-równań-1-rzędu">Równanie różniczkowe 2 rzędu jako układ równań 1 rzędu</h2>
<p>Niech będzie dane równanie różniczkowe 2 rzędu:
$$ \frac{d^2 y}{dx^2}=f(x, y, y’). $$
Podstawienie $ u=y’ $ daje nam układ równań pierwszego rzędu
$$
\begin{cases} u’ = f(x, y, u) \\ u=y’=g(x,y,u) \end{cases} 
$$</p>

<h3 id="przykład-1">Przykład</h3>
<p>Rozważmy równanie ruchu tłumionego oscylatora harmonicznego:
$$ \ddot{x}+2\beta m\dot{x}+\omega_0^2 x = 0. $$
Podstawienie $v=\dot{x}$ daje nam układ równań
$$
\begin{cases} \dot{v}=-2\beta v-\omega_0^2 x \\ v=\dot{x}  \end{cases}
$$</p>

<h2 id="numeryczne-rozwiązywanie-równań-2-rzędu">Numeryczne rozwiązywanie równań 2 rzędu</h2>
<p>Aby numerycznie rozwiązać równanie 2 rzędu musimy mieć dane $y(x_0)$ oraz $u(x_0)$, gdzie $x_0$ to pewna wartość początkowa zmiennej.</p>

<p>W pierwszej kolejności obliczamy $k_1$ dla obydwu równań:
$$ k_{1y}=g(x, y, u), $$
gdzie $g(x, y, u)=u$.
$$ k_{1u}=f(x, y, u) $$
Aby obliczyć $k_{2y}$, za $u$ podstawiamy $u+k_{1u}\Delta x/2$:
$$ k_{2y}=g(x+\frac{\Delta x}{2}, y+k_{1y}\frac{\Delta x}{2}, u+k_{1u}\frac{\Delta x}{2}) $$
i podobnie obliczamy $k_{2u}$:
$$ k_{2u}=f(x+\frac{\Delta x}{2}, y+k_{1y}\frac{\Delta x}{2}, u+k_{1u}\frac{\Delta x}{2}). $$
Prodecura wygląda analogicznie dla $k_3$ i $k_4$. Finalnie możemy obliczyć $y(x+\Delta x)$:
$$ y(x+\Delta x)=y(x)+\frac{\Delta x}{6}(k_{1y}+2k_{2y}+2k_{3y}+k_{4y}) $$
i analogicznie $u$.</p>

<h3 id="przykład-2">Przykład</h3>
<p>Rozważmy wcześniejsze równanie ruchu tłumionego oscylatora harmonicznego z warunkami początkowymi $x(0)=0$ i $v(0)=1$ oraz parametrami $\omega_0=2$, $\beta=0.5$, $m=1$.</p>

<p>Zdefiniujmy zmienne i warunki początkowe:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// warunki początkowe</span>
<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t_max</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// jak daleko ma sięgać symulacja</span>
<span class="kt">float</span> <span class="n">step</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span> <span class="c1">// Delta x</span>
<span class="c1">// parametry układu</span>
<span class="kt">float</span> <span class="n">omega_0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</code></pre></div></div>
<p>Następnie zdefiniujmy funkcje $f(x)$ i $g(x)$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja obliczająca dv/dt</span>
<span class="kt">float</span> <span class="nf">f</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">v</span><span class="o">-</span><span class="n">omega_0</span><span class="o">*</span><span class="n">omega_0</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// funkcja obliczająca dx/dt</span>
<span class="kt">float</span> <span class="nf">g</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Utwórzmy funkcję, która oblicza kolejne wartości $x$ i $v$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja obliczająca następną wartość x  z użyciem metody Rungego-Kutty</span>
<span class="kt">void</span> <span class="nf">next</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// obliczamy wszystkie k dla obu równań</span>
	<span class="kt">float</span> <span class="n">k_1x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_1v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_2x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_1x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_1v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_2v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_1x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_1v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_3x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_2x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_2v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_3v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_2x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_2v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_4x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_3x</span><span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_3v</span><span class="o">*</span><span class="n">step</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_4v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_3x</span><span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_3v</span><span class="o">*</span><span class="n">step</span><span class="p">);</span>
	
	<span class="c1">// obliczamy kolejne wartości dla x oraz v</span>
	<span class="o">::</span><span class="n">x</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3x</span><span class="o">+</span><span class="n">k_4x</span><span class="p">);</span>
	<span class="o">::</span><span class="n">v</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1v</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2v</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3v</span><span class="o">+</span><span class="n">k_4v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Należy pamiętać, aby również obliczać kolejne wartości dla $v$, ponieważ w przeciwnym razie pochodna będzie cały czas stała. Możemy teraz utworzyć pętlę w funkcji <code class="language-plaintext highlighter-rouge">main()</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">t_max</span><span class="o">-</span><span class="n">t_min</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span>
    <span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span>  <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// zapisujemy wyniki do pliku</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Podobnie jak wcześniej wyniki oraz rozwiązanie analityczne naniosłem na jeden wykres, otrzymując idealną zgodność:</p>
<p align="center">
<img src="/assets/images/2025-06-30/przyklad2.svg" width="500" />
</p>

<p>Pełne pliki źródłowe są dostępne do pobrania tutaj: <br />
<a href="/assets/downloads/2025-06-30/przykład1.cpp" target="_blank">przykład1.cpp</a> <br />
<a href="/assets/downloads/2025-06-30/przykład2.cpp" target="_blank">przykład2.cpp</a></p>

<h2 id="uogólnienie-na-równania-wyższych-rzędów">Uogólnienie na równania wyższych rzędów</h2>
<p>W takim przypadku ponownie rozpisujemy równanie $n$-tego rzędu jako układ $n$ równań różniczkowych 1 rzędu, np.
$$
\begin{cases} \dot{x_1}=f_1(t, x_1, x_2, \dots, x_n) \\ \dot{x_2}=f_2(t, x_1, x_2, \dots, x_n) \\ \dots \\ \dot{x_n}=f_n(t, x_1, x_2, \dots, x_n) \end{cases}
$$
Niech $\mathbf{x}=(x_1,x_2,\dots,x_n)^\intercal$ oraz $\mathbf{f}(t, \mathbf{x})=(f_1(t, \mathbf{x}), f_2(t, \mathbf{x}), \dots, f_n(t, \mathbf{x}))^\intercal$. Wtedy układ równań możemy zapisać jako 
$$ \dot{\mathbf{x}}=\mathbf{f}(t, \mathbf{x}) $$
Obliczamy teraz $\mathbf{k_1}, \mathbf{k_2}, \dots$:
$$ \mathbf{k_1}=\mathbf{f}(t, \mathbf{x}) $$
$$ \mathbf{k_2}=\mathbf{f}(t+\frac{\Delta t}{2}, \mathbf{x}+\mathbf{k_1}\frac{\Delta t}{2}) $$
itd.
W przypadku $n=2$ wszystko sprowadza się do opisanego wcześniej algorytmu.</p>]]></content><author><name></name></author><category term="Programowanie" /><summary type="html"><![CDATA[Algorytm Rungego-Kutty Mamy dane równanie różniczkowe 1 rzędu w postaci $$ \frac{dy}{dx}=f(x,y). $$ Najprostszą metodą, aby rozwiązać tego typu równanie numerycznie jest metoda Eulera. Pochodną możemy przybliżyć jako $$ \frac{dy}{dx}\approx\frac{y(x+\Delta x)-y(x)}{\Delta x}, $$ a stąd $$ y(x+\Delta x)\approx y(x)+\Delta x f(x,y). $$ Metoda ta jest bardzo niedokładna szczególnie dla rozwiązań oscylujących. Jest ona również nazywana algorytmem Rungego-Kutty 1 rzędu.]]></summary></entry><entry><title type="html">Wyznaczanie gęstości powietrza za pomocą wahadła matematycznego</title><link href="http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego" rel="alternate" type="text/html" title="Wyznaczanie gęstości powietrza za pomocą wahadła matematycznego" /><published>2025-06-18T00:00:00+02:00</published><updated>2025-06-18T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego</id><content type="html" xml:base="http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego"><![CDATA[<h2 id="tłumione-wahadło-matematyczne">Tłumione wahadło matematyczne</h2>
<p>Rozważmy najprostszy model wahadła. Jest to masa punktowa $m$ zawieszona na nieważkiej lince o długości $l$. Na wahadło działa siła ciężkości $\mathbf{Q}$, która rozkłada się na składową radialną i styczną do linki oraz siła reakcji linki $\mathbf{F_r}$, która równoważy $\mathbf{Q_r}$. Na masę działa również siła oporu $\mathbf{F_o}$. Poniżej został przedstawiony schemat tego układu.</p>

<p align="center">
<img src="/assets/images/2025-06-18/wahadlotlumione.svg" width="500" />
</p>

<p>Przy małych prędkościach wartość siły oporu $\mathbf{F_o}$  działającej na naszą masę jest wprost proporcjonalna do prędkości tego ciała. Dlatego założymy, że nasze wahadło porusza się z niewielką prędkością. Pozwoli nam to zapisać 2 zasadę dynamiki jako
$$ \mathbf{M}=\mathbf{l}\times\mathbf{Q_s}+\mathbf{l}\times\mathbf{F_o}, $$
gdzie $\mathbf{l}$ to wektor łączący punkt zaczepienia wahadła i masę $m$.</p>

<p>Niech $\hat{\mathbf{n}}$ będzie wektorem jednostkowym leżącym na tym samym kierunku co $\mathbf{Q_s}$ i o zwrocie w lewo. Wtedy $\mathbf{Q_s}=Q_s\hat{\mathbf{n}}$. Wiadomo, że $Q_s=Q\sin\theta=mg\sin\theta$, czyli $\mathbf{Q_s}=mg\sin\theta\,\hat{\mathbf{n}}$. Wtedy $\mathbf{l}\times\mathbf{Q_s}=mg\sin\theta\,\mathbf{l}\times\hat{\mathbf{n}}$. Łatwo zauważyć, że $\mathbf{l}\times\hat{\mathbf{n}}=-l\hat{\mathbf{k}}$, przy czym oś $z$ jest skierowana od ekranu. Zatem $\mathbf{l}\times\mathbf{Q_s}=-mgl\sin\theta\,\hat{\mathbf{k}}$.</p>

<p>Jak wspomniano wcześniej, $\mathbf{F_o}=-2\beta m\mathbf{v}$, gdzie $\beta$ to pewna stała - współczynnik tłumienia, a czynnik $2m$ ułatwi późniejsze obliczenia. Wiemy, że $\mathbf{v}=\boldsymbol{\dot{\theta}}\times\mathbf{l}$, a $\boldsymbol{\dot{\theta}}=\dot{\theta}\hat{\mathbf{k}}$. Na podstawie reguły prawej ręki możemy stwierdzić, że $\mathbf{v}=-\dot{\theta}l\hat{\mathbf{n}}$, a co za tym idzie $\mathbf{F_o}=2\beta ml\dot{\theta}\,\hat{\mathbf{n}}$. Teraz możemy obliczyć moment siły oporów:
$$ \mathbf{l}\times\mathbf{F_o}=2\beta ml\dot{\theta}\,{\mathbf{l}}\times\hat{\mathbf{n}}=-2\beta ml^2\dot{\theta}\,\hat{\mathbf{k}}.$$</p>

<p>Wiemy również, że $\mathbf{M}=I\ddot{\theta}\hat{\mathbf{k}}$, gdzie $I$ to moment bezwładności wahadła wokół punktu zaczepienia. Dla masy punktowej będzie to $ml^2$. Możemy teraz zapisać 2 zasadę dynamiki jako
$$ ml^2\ddot{\theta}\hat{\mathbf{k}}=-mgl\sin{\theta}\,\hat{\mathbf{k}}-2\beta ml^2\dot{\theta}\,\hat{\mathbf{k}}, $$
a po podzieleniu przez $ml^2\hat{\mathbf{k}}$ otrzymamy
$$ \ddot{\theta}+2\beta\dot{\theta}+\frac{g}{l}\sin{\theta}=0. $$
Gdy $\theta$ jest małym kątem, zachodzi w przybliżeniu równość $\sin\theta\approx\theta$, co pozwala nam zapisać 
$$ \ddot{\theta}+2\beta\dot{\theta}+\omega_0^2\theta=0, $$
gdzie $\omega_0=\sqrt{g/l}$.</p>

<p>Równanie charakterystyczne to
$$ r^2+2\beta r+\omega_0^2=0, $$
a jego rozwiązania to
$$ r=-\beta\pm i\omega, $$
gdzie $\omega=\sqrt{\omega_0^2-\beta^2}$. Rozwiązanie ogólne to wtedy
$$ \theta=e^{-\beta t}\left(Ae^{i\omega}+Be^{-i\omega}\right), $$
gdzie $A$ i $B$ to pewne stałe. Zapis ten jest równoważny
$$ \theta=e^{-\beta t}\left[(A+B)\cos\omega t+(A-B)i\sin\omega t\right]. $$
$\theta$ musi być liczbą rzeczywistą, dlatego $B=\overline{A}$. Niech $A=a+bi$, wtedy $B=a-bi$. Wstawiając to do powyższego równania otrzymamy
$$ \theta=e^{-\beta t}\left(2a\cos\omega t-2b\sin\omega t\right). $$
Ponieważ w nawiasie znajduje się liniowa kombinacja sinusa i cosinusa, możemy zapisać
$$ \theta=\theta_0 e^{-\beta t}\cos(\omega t+\varphi), $$
gdzie $\theta_0$ to amplituda drgań, a $\varphi$ to faza.</p>

<h2 id="pomiar-współczynnika-tłumienia">Pomiar współczynnika tłumienia</h2>
<p>Skonstruowano wahadło z cienkiej, w przybliżeniu nieważkiej nitki oraz śruby zamocowanej na jej końcu. Ponieważ rozmiary śruby były znacznie mniejsze niż długość wahadła, cała masa była w przybliżeniu skoncentrowana w jednym punkcie. Nitka została owinięta wokół cienkiego patyczka służącego jako punkt zaczepienia. Taki sposób zaczepienia linki umożliwił łatwą regulację długości wahadła. Zakładamy, że współczynnik tłumienia jest na tyle mały, że $\omega\approx\omega_0$.</p>

<p>Mierząc wartość $\theta$, gdy $\cos(\omega t+\varphi)=1$ (gdy wahadło jest w swoim maksymalnym wychyleniu) możemy wyznaczyć $\beta$. Czas mierzymy od chwili puszczenia wahadła, więc $\varphi=0$. Warunek zachodzi w bardzo dobrym przybliżeniu dla małych wychyleń (ponieważ $T$ tak naprawdę zależy od amplitudy), gdy $t=nT$, gdzie $T$ to okres wahadła, a $n=0,1,2,\dots$.
$$		\theta(nT)=\theta_0 e^{-\beta nT} $$
$$		\ln{\theta(nT)}=\ln{\theta_0}+-\beta nT $$
Sporządzając wykres $\ln{\theta(nT)}$ możemy wyznaczyć $\beta$ nawet bez znajomości $\theta_0$, ponieważ będzie to współczynnik kierunkowy prostej najlepszego dopasowania.</p>

<p>Wahadło zostało umieszczone w odległości $d=2$cm od biurka, do którego została przyklejona kartka papieru w kratkę. Aby dokładnie zaznaczać kolejne maksymalne wychylenia wahadła, w odległości $d’&gt;1$m od wahadła zostało umieszczone źródło światła, zgodnie ze schematem.</p>
<p align="center">
<img src="/assets/images/2025-06-18/ukladpom.svg" width="500" />
</p>

<p>Cień rzucany przez linkę różnił się o $\Delta x’$ od prawdziwego jej położenia. Przy wymienionych wcześniej wartościach $d$ i $d’$, $\Delta x’&lt;0.02\Delta x$, zatem błąd jest pomijalny. Błąd związany z wyznaczeniem czasu również został pominięty, ponieważ dla tak małych wychyleń okres był w bardzo dobrym przybliżeniu stały i wahadło służyło jako zegar.</p>

<p>Co 5 okresów na kartce były zaznaczane maksymalne wychylenia wahadła. Następnie została zmierzona odległość linii, na której były zaznaczane kolejne położenia wahadła, od punktu zaczepienia wahadła ($h$), aby wyznaczyć $\tan{\theta}=\Delta x/h$. Ponieważ wychylenia były małe, $\theta\approx\tan{\theta}$. Wyniki pomiarów dla $l=0.8\text{m}$ zostały zestawione na poniższych wykresach.</p>
<p align="center">
<img src="/assets/images/2025-06-18/wykresbeta.svg" width="700" />
</p>

<p>W tym układzie otrzymana wartość $\beta$ to
$$	\beta = 0.01478\pm0.0002\frac{1}{\text{s}} $$
Tak mała niepewność wynika z kilku czynników. Niepewność w pomiarze kąta była bardzo niewielka, ponieważ źródło światła umożliwiało precyzyjne wyznaczenie wychylenia wahadła, a ze względu na dużą odległość $h$ zaznaczanych punktów od osi obrotu, niewielkie zmiany kąta powodowały dużą zmianę w odległości $\Delta x$. Niepewność w pomiarze czasu była pomijalna. Niepewność związana z wzięciem logarytmu naturalnego jest dana w przybliżeniu wzorem
$$	\Delta(\ln x)\approx\frac{\Delta x}{x}. $$
W tym przypadku $\Delta x$ było rzędu $10^{-3}$, a $x$ rzędu $10^{-1}$, czyli niepewność była rzędu $10^{-2}$.</p>

<p>Współczynniki tłumienia wyznaczone dla wielu wahadeł umieściłem na widocznym poniżej wykresie zależności $\beta(l)$. Okazało się, że w dobrym przybliżeniu punkty pomiarowe układają się na prostej o współczynniku kierunkowym $a=(0.0073\pm0.0019)\frac{1}{\text{sm}}$ i wyrazie wolnym $b=(0.0092\pm0.0012)\frac{1}{\text{s}}$. Jak wyjaśnić tę obserwację?</p>
<p align="center">
<img src="/assets/images/2025-06-18/wykresbetal.svg" width="700" />
</p>

<h2 id="wyjaśnienie-zaobserwowanej-zależności">Wyjaśnienie zaobserwowanej zależności</h2>
<p>Można spekulować, że wyraz wolny to część współczynnika tłumienia pochodząca od śruby służącej jako masa na końcu wahadła, a $al$ to wkład pochodzący od nitki.</p>

<p>Prawo Stokesa mówi, że wartość siły działającej na kulę o promieniu $R$ poruszającą się z małą prędkością $v$ w płynie jest dana wzorem
$$	F_o=6\pi\mu R v, $$
gdzie $\mu$ to lepkość dynamiczna. Nitkę można przybliżyć jako złożoną z $l/w$ kul o średnicy $w$, gdzie $w$ to również szerokość nitki, ułożonych jedna za drugą. Promień takiej kuli to wtedy $R=w/2$. Całkowita siła działająca na nitkę to suma sił pochodzących od jej wszystkich małych kul. Każda z nich ma jednak inną prędkość, ponieważ znajduje się w innej odległości od osi obrotu.
$$	F=\sum_{i=0}^{l/w}6\pi\mu\frac{w}{2}v_i=3\pi\mu w\omega\sum_{i=0}^{l/w} r_i, $$
gdzie $r_i$ to odległość $i$-tej kuli od osi obrotu. Aby obliczyć sumę, zapiszmy
$$	\sum_{i=0}^{l/w} r_i=\frac{1}{w}\sum_{i=0}^{l/w} r_i w. $$
Ponieważ $w$ jest małe w porównaniu do $l$, możemy aproksymować sumę jako całkę. Wtedy $w = \Delta r_i$, czyli
$$	\frac{1}{w}\sum_{i=0}^{l/w} r_i w\approx\frac{1}{w}\int_{0}^{l}r\,dr=\frac{l^2}{2w}.$$
Wstawiając ten wynik do wcześniejszego wzoru otrzymujemy
$$	F\approx \frac{3}{2}\pi\mu lv,$$
gdzie $v$ to prędkość końca wahadła. Ponieważ $F=2\beta m v$, zachodzi równość
$$
	\beta=\frac{3\pi\mu}{4m}l,
    $$
co wyjaśnia zaobserwowaną zależność.</p>

<h2 id="wyznaczanie-lepkości-dynamicznej-powietrza">Wyznaczanie lepkości dynamicznej powietrza</h2>
<p>Całkowita siła oporu działająca na wahadło to
$$	F=2\beta mv=2almv+2bmv,$$
gdzie m to masa śrubki zawieszonej na końcu wahadła (masa nitki jest pomijalna). Pierwszy wyraz po prawej stronie to siła pochodząca od nitki, czyli przyrównując to do wcześniej obliczonej siły otrzymujemy
$$		2almv=\frac{3}{2}\pi\mu lv $$
$$		4am=3\pi \mu $$
$$		\mu=\frac{4am}{3\pi}. $$
Zmierzona masa śrubki to $m=(4\pm 0.5)$g oraz $a=(0.0073\pm0.0019)\frac{1}{\text{ms}}$. Przy tych danych
	$$ \mu=(12.4\pm4.8)\times 10^{-6}\text{ Pa s},$$
przy czym tablicowa wartość $\mu$ dla powietrza w temperaturze $293\text{K}$ to $\mu=18.13\times 10^{-6}\text{ Pa s}$.</p>

<h2 id="wyznaczanie-gęstości-powietrza">Wyznaczanie gęstości powietrza</h2>
<p>Kinetyczna teoria gazów daje następujący wzór dla rozrzedzonych gazów:
$$	\mu=\alpha\rho\lambda\sqrt{\frac{2k_B T}{\pi m}},$$
gdzie bezwymiarowy współczynnik $\alpha\approx 1$, $\rho$ to gęstość gazu, $\lambda$ to średnia droga swobodna w tym gazie, $T$ to temperatura, a $m$ to masa cząsteczkowa. Przekształćmy ten wzór do postaci
$$	\rho=\frac{\mu}{\alpha\lambda}\sqrt{\frac{\pi m}{2k_B T}}.$$
Dla powietrza $m\approx29\text{u}\approx 4.28\times 10^{-26}\text{kg}$, $\lambda\approx6,6\times 10^{-8}$m. Temperatura podczas pomiarów wynosiła ok. $T\approx293\text{K}$. Wstawiając te dane do wzoru otrzymujemy wynik 
$$	\rho=(0.77\pm0.30)\frac{\text{kg}}{\text{m}^3},$$
przy czym tablicowa wartość w tej temperaturze to $\rho=1.20\frac{\text{kg}}{\text{m}^3}$. Wynik jest obarczony dużą niepewnością spowodowaną głównie niepewnością $m$ i $\mu$. Należy również zauważyć, że prawdziwa wartość $\rho$ nie mieści się w przedziale niepewności. Jest to najprawdopodobniej spowodowane przybliżeniem nitki jako złożonej z wielu kul.</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Tłumione wahadło matematyczne Rozważmy najprostszy model wahadła. Jest to masa punktowa $m$ zawieszona na nieważkiej lince o długości $l$. Na wahadło działa siła ciężkości $\mathbf{Q}$, która rozkłada się na składową radialną i styczną do linki oraz siła reakcji linki $\mathbf{F_r}$, która równoważy $\mathbf{Q_r}$. Na masę działa również siła oporu $\mathbf{F_o}$. Poniżej został przedstawiony schemat tego układu.]]></summary></entry></feed>