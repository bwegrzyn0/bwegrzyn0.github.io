<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-07-31T11:03:55+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">bwegrzyn0.github.io</title><subtitle>Fizyka i programowanie</subtitle><entry><title type="html">fraktale-obrazy: Program umożliwiąjący generowanie fraktali</title><link href="http://localhost:4000/programowanie/fraktale-obrazy-program-umo%C5%BCliwiaj%C4%85cy-generowanie-fraktali" rel="alternate" type="text/html" title="fraktale-obrazy: Program umożliwiąjący generowanie fraktali" /><published>2025-07-31T00:00:00+02:00</published><updated>2025-07-31T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/fraktale-obrazy-program-umo%C5%BCliwiaj%C4%85cy-generowanie-fraktali</id><content type="html" xml:base="http://localhost:4000/programowanie/fraktale-obrazy-program-umo%C5%BCliwiaj%C4%85cy-generowanie-fraktali"><![CDATA[<p align="center">
<img src="/assets/images/2025-07-31/readme_image.jpg" width="700" />
<br />
<em>Obraz wygenerowany z użyciem programu</em>
</p>

<h1 id="fraktale-obrazy">fraktale-obrazy</h1>
<p>Prosty program napisany w C++ z użyciem biblioteki SDL2, który umożliwia generowanie i zapisywanie obrazów fraktali.</p>

<blockquote>
  <p><strong>Uwaga!</strong> <br />
Początkowo miał być to mały projekt, lecz nieco się rozrósł. Program może być niewydajny i zbugowany.</p>
</blockquote>

<p>Jest to <a href="https://github.com/bwegrzyn0/fraktale-obrazy" target="_blank">plik README z repozytorium GitHub</a> przetłumaczony na język polski.</p>

<h2 id="instalacja-programu">Instalacja programu</h2>
<p>Zklonuj repozytorium GitHub:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/bwegrzyn0/fraktale-obrazy
</code></pre></div></div>
<p>i uruchom program za pomocą komendy <code class="language-plaintext highlighter-rouge">./run.out</code>.</p>

<h2 id="użytkowanie">Użytkowanie</h2>
<p>W oknie zobaczysz następujący interfejs:</p>

<p align="center">
<img src="/assets/images/2025-07-31/interface_image.jpg" width="600" />
</p>

<p>Radzę samodzielnie wypróbować poszczególne opcje aby zobaczyć ich efekt na obrazie. Tutaj po krótce omówię każdą z nich:</p>
<ul>
  <li><strong>Brightness multiplier</strong>: mnoży jasność wszystkich pikseli przez zadaną wartość.</li>
  <li><strong>Resolution</strong>: liczba pikseli na jednostkę długosci. Na przykład, jeśli szerokość obszaru (omawiana dalej) wynosi 10, a rozdzielczość wynosi 100, obraz będzie miał szerokość 100 * 10 = 1000 pikseli. Bardzo duże wartości negatywnie wpływają na wydajność programu. Z tego powodu przy oddalaniu widoku rozdzielczość jest dynamicznie zminiejszana (nie ma to wpływu na zapisywany obraz).</li>
  <li><strong>Number of iterations</strong>: liczba iteracji algorytmu IFSP.</li>
  <li><strong>Number of points</strong>: liczba punktów w algorytmie IFSP.</li>
  <li><strong>Area X and Area Y</strong>: współrzędne X i Y obszaru generacji fraktala.</li>
  <li><strong>Area width and Area height</strong>: szerokość i wysokość obszaru generacji fraktala.</li>
  <li><strong>Show area border</strong>: pozwala przełączać widoczność czerwonej granicy wokół obszaru generacji fraktala.</li>
  <li>
    <p><strong>Transformation parameters</strong>: maksymalnie można mieć 4 transformacje. Każdą z nich charakteryzuje 7 liczb. Współrzędne są transformowane według następujących zależności:</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>transformowane_x = a_x * x + b_x * y + c_x
transformowane_y = a_y * x + b_y * y + c_y
</code></pre></div>    </div>
    <p>Każda transformacja ma swoje prawdopodobieństwo, które nie wpływa na kształt fraktala. Zmienia ono jedynie gęstość rozłożenia punktów na nim.</p>
    <blockquote>
      <p><strong>Wskazówka</strong> <br />
Jeśli potrzebne są jedynie np. 2 transformacje, należy ustawić prawdopodobieństwa pozostałych dwóch na zero.</p>
    </blockquote>
  </li>
  <li><strong>Image file name</strong>: nazwa pliku z obrazem fraktala (bez rozszerzenia).</li>
</ul>

<p>Obrazy są zapisywane w formacie <code class="language-plaintext highlighter-rouge">.bmp</code> w katalogu, w którym znajduje się program.</p>

<p>Można poruszać się i przybliżać obraz fraktala w programie za pomocą strzałek i scrolla.</p>

<h2 id="jak-działa-ten-program">Jak działa ten program?</h2>
<p>Wybrana liczba puntków jest jednorodnie rozłożona w kwadracie, po czym są one poddawane algorytmowi IFSP. Każdy piksel posiada gęstość równą liczbie punktów, która w nim wylądowała. Jego jasność jest ustalana na podstawie gęstości - piksele z 0 punktami są czarne, a piksele z największą ich liczbą białe.</p>

<h2 id="przykładowe-obrazy">Przykładowe obrazy</h2>
<p align="center">
<img src="/assets/images/2025-07-31/bazia.jpg" width="600" />
</p>
<p align="center">
<img src="/assets/images/2025-07-31/choinka.jpg" width="600" />
</p>
<p align="center">
<img src="/assets/images/2025-07-31/sierpinsk.jpg" width="600" />
</p>
<p align="center">
<img src="/assets/images/2025-07-31/dragon.jpg" width="600" />
</p>

<h2 id="licencja">Licencja</h2>
<p>Program nie posiada licencji i może być używany w dowolny sposób.</p>]]></content><author><name></name></author><category term="Programowanie" /><summary type="html"><![CDATA[Obraz wygenerowany z użyciem programu]]></summary></entry><entry><title type="html">Mechanika Lagrange’a, część 3: Układy nieswobodne</title><link href="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-3-uk%C5%82ady-nieswobodne" rel="alternate" type="text/html" title="Mechanika Lagrange’a, część 3: Układy nieswobodne" /><published>2025-07-25T00:00:00+02:00</published><updated>2025-07-25T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-3-uk%C5%82ady-nieswobodne</id><content type="html" xml:base="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-3-uk%C5%82ady-nieswobodne"><![CDATA[<h2 id="układ-nieswobodny">Układ nieswobodny</h2>
<p>Do tej pory opisywalśmy ruch cząstki przy założeniu, że jej ruch jest swobodny. Teraz zajmiemy się przypadkiem, gdy jej ruch jest ograniczony <strong>więzami</strong>.</p>

<p>Rozważmy cząstkę poruszającą się w 3 wymiarach, której ruch jest ograniczony do pewnej powierzchni (na przykład kula znajdująca się między dwoma płytkami uniemożliwiającymi jej ruch w kierunku prostopadłym do ich powierzchni). W mechanice Newtona oznacza to, że na kulę działa siła reakcji prostopadła do powierzchni ograniczającej jej ruch, jak zostało pokazane na rysunku. $\hat{T}$ oznacza wektor styczny do kierunku ruchu i zarazem płaszczyzny.</p>

<p align="center">
<img src="/assets/images/2025-07-25/siła_reakcji.svg" width="500" />
</p>

<p>Mimo tego, że cząstka porusza się w przestrzeni 3-wymiarowej, do opisania jej położenia potrzebujemy jedynie 2 współrzędnych $q_1$ i $q_2$ (ponieważ jej ruch jest ograniczony do powierzchni). Spodziewamy się zatem, że jej ruch będą w pełni opisywać równania Lagrange’a
$$ \frac{\partial\mathcal{L}}{\partial q_i}-\frac{d}{dt}\frac{\partial\mathcal{L}}{\partial \dot{q_i}}=0, $$
dla których lagranżjan jest dany wzorem
$$ \mathcal{L}=T-U, $$
gdzie $U$ jest energią potencjalną wszystkich sił (przy założeniu, że da się je zapisać jako jej gradient) <strong>oprócz sił reakcji</strong>. Innymi słowy
$$ \vec{F}_{cał.}=\vec{F}+\vec{F}_R=-\nabla U+\vec{F}_R, $$
gdzie $\vec{F}_R$ to siła reakcji, a $\vec{F}_{cał.}$ to siła całkowita działająca na cząstkę.</p>

<p>Chcielibyśmy udowodnić, że to sformułowanie jest równoważne sformułowaniu newtonowskiemu.</p>

<h3 id="dowód">Dowód</h3>
<p>Rozważmy ruch cząstki w czasie od $t_1$ do $t_2$ po torze $\vec{r}$.
Powyższe twierdzenie jest równoważne temu, że wariacja działania wynosi 0:
$$ \delta S=\delta \int_{t_1}^{t_2}\mathcal{L}(\vec{r}, \dot{\vec{r}}, t)\,dt =0$$
Rozważmy zatem tor $\vec{R}=\vec{r}+\vec{\varepsilon}$, gdzie $\vec{\varepsilon}$ wynosi $\vec{0}$ dla $t_1$ i $t_2$ oraz nie wychodzi poza powierzchnię ruchu cząstki (cząstka dalej pozostaje ograniczona). Zostało to zilustrowane na poniższym rysunku, gdzie kolorem białym została oznaczona prawdziwa trajektoria cząstki, a niebieskim $\vec{R}$. Ruch cząstki jest ograniczony do zielonej płaszczyzny.</p>

<p align="center">
<img src="/assets/images/2025-07-25/wykres_powierzchnia.svg" width="500" />
</p>

<p>Wariacja działania to wtedy
$$ \delta S=\int_{t_1}^{t_2}\left[\mathcal{L}(\vec{R}, \dot{\vec{R}}, t)-\mathcal{L}(\vec{r}, \dot{\vec{r}}, t)\right]\,dt$$
Obliczmy różnicę znajdującą się pod całką:
$$ \mathcal{L}(\vec{R}, \dot{\vec{R}}, t)-\mathcal{L}(\vec{r}, \dot{\vec{r}}, t)=T(\vec{R}, \dot{\vec{R}}, t)-U(\vec{R}, t)-T(\vec{r}, \dot{\vec{r}}, t)+U(\vec{r}, t)$$
Wyznaczmy poszczególne wyrazy:
$$ T(\vec{R}, \dot{\vec{R}}, t)=\frac{1}{2}m\dot{R}^2=\frac{1}{2}m\left(\dot{\vec{r}}+\dot{\vec{\varepsilon}}\right)^2=\frac{1}{2}m\left(\dot{r}^2+2\dot{\vec{r}}\cdot\dot{\vec{\varepsilon}}+\dot{\varepsilon}^2\right)$$
$$ T(\vec{R}, \dot{\vec{R}}, t)-T(\vec{r}, \dot{\vec{r}}, t)=\frac{1}{2}m\left(\dot{r}^2+2\dot{\vec{r}}\cdot\dot{\vec{\varepsilon}}+\dot{\varepsilon}^2\right)-\frac{1}{2}m\dot{r}^2=m\dot{\vec{r}}\cdot\dot{\vec{\varepsilon}}+\frac{1}{2}m\dot{\varepsilon}^2$$
Ponieważ $\varepsilon$ oraz $\dot{\varepsilon}$ są małe
$$ T(\vec{R}, \dot{\vec{R}}, t)-T(\vec{r}, \dot{\vec{r}}, t)\approx m\dot{\vec{r}}\cdot\dot{\vec{\varepsilon}}.$$
Obliczmy teraz różnicę 
$$ -U(\vec{R}, t)+U(\vec{r}, t)=-\left[ U(\vec{r}+\vec{\varepsilon}, t)-U(\vec{r}, t) \right]\approx-\left[ U(\vec{r}, t)+\vec{\varepsilon}\cdot\nabla U(\vec{r}, t)-U(\vec{r}, t)\right]=-\vec{\varepsilon}\cdot\nabla U(\vec{r}, t)$$
Wracając, mamy
$$ \mathcal{L}(\vec{R}, \dot{\vec{R}}, t)-\mathcal{L}(\vec{r}, \dot{\vec{r}}, t)\approx m\dot{\vec{r}}\cdot\dot{\vec{\varepsilon}}-\vec{\varepsilon}\cdot\nabla U(\vec{r}, t)$$
Wstawmy to do całki:
$$ \delta S=\int_{t_1}^{t_2}\left[ m\dot{\vec{r}}\cdot\dot{\vec{\varepsilon}}-\vec{\varepsilon}\cdot\nabla U(\vec{r}, t) \right]\,dt $$
Aby pozbyć się $\dot{\vec{\varepsilon}}$, pocałkujmy pierwszy wyraz przez części:
$$ \int_{t_1}^{t_2} m\dot{\vec{r}}\cdot\dot{\vec{\varepsilon}} \,dt =\underbrace{\left[m\dot{\vec{r}}\cdot\vec{\varepsilon} \right]_{t_1}^{t_2}}_{=0} -\int_{t_1}^{t_2} m\ddot{\vec{r}}\cdot\vec{\varepsilon}\,dt, $$
co daje nam 
$$ \delta S=\int_{t_1}^{t_2}\vec{\varepsilon}\cdot\left[-m\ddot{\vec{r}} -\nabla U(\vec{r}, t) \right]\,dt. $$
Zauważmy teraz, że $m\ddot{\vec{r}}=\vec{F}_{cał.}$ oraz $-\nabla U(\vec{r}, t)=\vec{F}$:
$$ \delta S=\int_{t_1}^{t_2}\vec{\varepsilon}\cdot\left[-\vec{F}_{cał.}+\vec{F}\right]\,dt$$
Wiemy, że $-\vec{F}_{cał.}+\vec{F}=-\vec{F}-\vec{F}_R+\vec{F}=-\vec{F}_R$, zatem
$$ \delta S =-\int_{t_1}^{t_2}\vec{\varepsilon}\cdot\vec{F}_R\,dt. $$
Jak wspomnieliśmy wcześniej, siły reakcji są <strong>zawsze prostopadłe</strong> do powierzchni ruchu cząstki, a $\vec{\varepsilon}$ wybraliśmy takie, aby w tej powierzchni leżało. Oznacza to, że $\vec{\varepsilon}\cdot\vec{F}_R=0$, a co za tym idzie
$$ \delta S = 0, $$
co kończy dowód.</p>

<p>Analogiczny dowód można przeprowadzić dla cząstki ograniczonej do ruchu jedynie po krzywej.</p>

<h2 id="przykład">Przykład</h2>
<p>Rozważmy piłkę toczącą się po równi pochyłej. Jej położenie można jednoznacznie określić za pomocą jednej zmiennej $x$. Jeśli oś $x$ wybierzemy tak, aby przebiegała równolegle do równi oraz $x=0$, gdy piłka jest u podstawy równi, jej energia potencjalna będzie dana wzorem
$$ U=mgh=mgx\sin\theta, $$
gdzie $\theta$ to kąt nachylenia równi (patrz rysunek poniżej).</p>

<p align="center">
<img src="/assets/images/2025-07-25/równia.svg" width="300" />
</p>

<p>W tym przypadku cząstka poruszająca się w 2 wymiarach jest ograniczona do 1 wymiaru poprzez siłę reakcji równi.
Lagranżjan piłki będzie wynosił
$$ \mathcal{L}=\frac{1}{2}m\dot{x}^2-mgx\sin\theta, $$
co po wstawieniu do równania Lagrange’a da nam
$$ m\ddot{x}=-mg\sin\theta. $$</p>

<h2 id="przykład-1">Przykład</h2>
<p>Rozważmy wahadło matematyczne o długości $l$, na którego końcu jest zawieszona masa $m$ o energii potencjalnej $U=-mgy=-mgl\cos{\theta}$ (patrz rysunek).</p>

<p align="center">
<img src="/assets/images/2025-07-25/wahadło.svg" width="600" />
</p>

<p>Masa jest ograniczona siłą reakcji linki i jej ruch można opisać za pomocą tylko zmiennej $\theta$. Lagranżjan tego wahadła to
$$ \mathcal{L}=\frac{1}{2}ml^2\dot{\theta}^2+mgl\cos{\theta}, $$
a wynikające z niego równanie ruchu to
$$ ml^2\ddot{\theta}+mgl\sin{\theta}=0. $$</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Układ nieswobodny Do tej pory opisywalśmy ruch cząstki przy założeniu, że jej ruch jest swobodny. Teraz zajmiemy się przypadkiem, gdy jej ruch jest ograniczony więzami.]]></summary></entry><entry><title type="html">Mechanika Lagrange’a, część 2: Zasada Hamiltona</title><link href="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-2-zasada-hamiltona" rel="alternate" type="text/html" title="Mechanika Lagrange’a, część 2: Zasada Hamiltona" /><published>2025-07-22T00:00:00+02:00</published><updated>2025-07-22T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-2-zasada-hamiltona</id><content type="html" xml:base="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-2-zasada-hamiltona"><![CDATA[<h2 id="zasada-hamiltona">Zasada Hamiltona</h2>
<p>Rozważmy swobodną cząstkę poruszającą się między punktami $1$ i $2$ w czasie od $t_1$ do $t_2$. Droga $\vec{r}(t)$, którą wybiera cząstka jest taka, że całka działania
$$ S=\int_{t_1}^{t_2}\mathcal{L}(\vec{r}, \dot{\vec{r}}, t)\,dt $$
jest minimalna (stacjonarna). $\mathcal{L}$ to <strong>lagranżjan</strong> układu zdefiniowany jako
$$ \mathcal{L}(\vec{r}, \dot{\vec{r}}, t)=T-U, $$
gdzie $T$ to energia kinetyczna cząstki, a $U$ to jej energia potencjalna.</p>

<h3 id="przykład---cząstka-swobodna-w-przestrzeni-3-wymiarowej">Przykład - cząstka swobodna w przestrzeni 3-wymiarowej</h3>
<p>Rozważmy cząstkę o położeniu $\vec{r}=(x,y,z)$ oraz prędkości $\dot{\vec{r}}=(\dot{x}, \dot{y}, \dot{z})$. Jej energia potencjalna w danej chwili to $U=mgz$, a energia kinetyczna to $T=\frac{1}{2}m\left( \dot{x}^2+\dot{y}^2+\dot{z}^2 \right)$. Wyznaczmy jej równania ruchu.</p>

<p>Funkcja Lagrange’a (lagranżjan) dla tej cząstki to
$$ \mathcal{L}=\frac{1}{2}m\left( \dot{x}^2+\dot{y}^2+\dot{z}^2 \right)-mgz $$
<a href="https://bwegrzyn0.github.io/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-1-r%C3%B3wnanie-eulera-lagrangea" target="_blank">W poprzednim artykule</a> dowiedzieliśmy się, że jeśli funkcja $\mathcal{L}$ sprawia, że całka jest minimalna, to spełnia ona równanie Eulera-Lagrange’a. W naszym przypadku mamy do czynienia z trzema zmiennymi, $x$, $y$ i $z$, więc potrzebujemy trzech równań:
$$ \frac{\partial \mathcal{L}}{\partial x}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{x}}=0$$
$$ \frac{\partial \mathcal{L}}{\partial y}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{y}}=0$$
$$ \frac{\partial \mathcal{L}}{\partial z}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{z}}=0$$
Obliczmy wszystkie pochodne:
$$ \frac{\partial \mathcal{L}}{\partial x}=\frac{\partial \mathcal{L}}{\partial y}=0 $$
$$ \frac{\partial \mathcal{L}}{\partial z}=mg $$
$$ \frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{x}}=\frac{d}{dt}\left(m\dot{x}\right)=m\ddot{x} $$
i analogicznie dla $y$ i $z$. Po wstawieniu mamy:
$$ m\ddot{x}=0 $$
$$ m\ddot{y}=0 $$
$$ m\ddot{z}=mg $$
Widzimy, że otrzymujemy 3 równania ruchu, takie same jak otrzymalibyśmy w przypadku użycia mechaniki Newtona. Zauważmy również, że pochodna $\mathcal{L}$ po współrzędnej jest równa dokładnie składowej siły działającej na cząstkę, a pochodna po składowej prędkości to składowa pędu:
$$\frac{\partial \mathcal{L}}{\partial x}=F_x$$
$$\frac{\partial \mathcal{L}}{\partial \dot{x}}=p_x$$
i analogicznie dla $y$ i $z$. Możemy wstawić to do równania Lagrange’a i otrzymamy dobrze znany wzór
$$ F_x=\frac{d}{dt}p_x, $$
co pokazuje, że w tym przypadku sformułowanie mechaniki Lagrange’a jest równoważne sformułowaniu Newtona.</p>

<h3 id="przykład---cząstka-poruszająca-się-pod-wpływem-potencjału-centralnego">Przykład - cząstka poruszająca się pod wpływem potencjału centralnego</h3>
<p>Rozważmy cząstkę swobodną o masie $m$ poruszającą się w potencjale $U=-GMm/r$, gdzie $r$ to odległość cząstki od początku układu współrzędnych. W tym przypadku najwygodniej będzie posłużyć się współrzędnymi biegunowymi (nie potrzebujemy wsp. sferycznych, ponieważ wiadomo że ruch będzie ograniczony do płaszczyzny) $r$ i $\theta$. Okazuje się, że mimo tego, że $\theta$ jest kątem, wciąż możemy traktować go jak inne współrzędne, np. $x$. Oznacza to, że 2 równania Lagrange’a, które otrzymamy to
$$ \frac{\partial \mathcal{L}}{\partial r}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{r}}=0$$
$$ \frac{\partial \mathcal{L}}{\partial \theta}-\frac{d}{dt}\frac{\partial \mathcal{L}}{\partial\dot{\theta}}=0$$
Obliczmy lagranżjan. Energia kinetyczna to
$$ T=\frac{1}{2}m\left[\dot{r}^2+(r\dot{\theta})^2\right], $$
a energię potencjalną znamy. Zatem
$$ \mathcal{L}=T-U=\frac{1}{2}m\left[\dot{r}^2+(r\dot{\theta})^2\right]+GMm\frac{1}{r}.$$
Obliczmy pochodne:
$$ \frac{\partial \mathcal{L}}{\partial r}=mr\dot{\theta}^2-GMm\frac{1}{r^2} $$
$$ \frac{\partial \mathcal{L}}{\partial \theta}=0$$
$$ \frac{d}{dt}\frac{\partial \mathcal{L}}{\partial \dot{r}}=m\ddot{r} $$
$$ \frac{d}{dt}\frac{\partial \mathcal{L}}{\partial \dot{\theta}}=mr^2\ddot{\theta} $$
i wstawmy je do naszych równań:
$$ m\ddot{r}=mr\dot{\theta}^2-GMm\frac{1}{r^2} $$
$$ mr^2\ddot{\theta}=0 $$
Otrzymujemy ponownie wyniki zgodne z mechaniką Newtona. Zauważmy, że ponownie 
$$\frac{\partial \mathcal{L}}{\partial r}=F_r, $$
gdzie $F_r$ to suma wszystkich sił radialnych działających na cząstkę. Możemy rozpoznać w niej siłę grawitacji oraz fikcyjną siłę odśrodkową.
$$ \frac{\partial \mathcal{L}}{\partial \dot{r}}=p_r,$$
gdzie $p_r$ to radialna składowa pędu cząstki. W przypadku kąta mamy
$$ \frac{\partial \mathcal{L}}{\partial \theta}=\Gamma, $$
gdzie $\Gamma$ to moment siły działający na cząstkę (w tym przypadku 0) oraz 
$$ \frac{\partial \mathcal{L}}{\partial \dot{\theta}}=L, $$
gdzie $L$ to moment pędu cząstki. Ponownie otrzymujemy dobrze znane równania
$$ F_r =\frac{d}{dt}p_r$$
$$ \Gamma = \frac{d}{dt} L. $$</p>

<p>Poprzednie 2 przykłady pokazały nam, że wielkości $\partial\mathcal{L}/\partial q_i$ oraz $\partial\mathcal{L}/\partial \dot{q}_i$, gdzie $q_i$ to pewna <strong>współrzędna uogólniona</strong> (np. $x$, $r$, $\theta$, $\varphi$) pełnią role kolejno siły oraz pędu. Dlatego są one nazywane <strong>siłą uogólnioną</strong> oraz <strong>pędem uogólnionym</strong>.</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Zasada Hamiltona Rozważmy swobodną cząstkę poruszającą się między punktami $1$ i $2$ w czasie od $t_1$ do $t_2$. Droga $\vec{r}(t)$, którą wybiera cząstka jest taka, że całka działania $$ S=\int_{t_1}^{t_2}\mathcal{L}(\vec{r}, \dot{\vec{r}}, t)\,dt $$ jest minimalna (stacjonarna). $\mathcal{L}$ to lagranżjan układu zdefiniowany jako $$ \mathcal{L}(\vec{r}, \dot{\vec{r}}, t)=T-U, $$ gdzie $T$ to energia kinetyczna cząstki, a $U$ to jej energia potencjalna.]]></summary></entry><entry><title type="html">Mechanika Lagrange’a, część 1: Równanie Eulera-Lagrange’a</title><link href="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-1-r%C3%B3wnanie-eulera-lagrangea" rel="alternate" type="text/html" title="Mechanika Lagrange’a, część 1: Równanie Eulera-Lagrange’a" /><published>2025-07-21T00:00:00+02:00</published><updated>2025-07-21T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-1-r%C3%B3wnanie-eulera-lagrangea</id><content type="html" xml:base="http://localhost:4000/mechanika/mechanika-lagrangea-cz%C4%99%C5%9B%C4%87-1-r%C3%B3wnanie-eulera-lagrangea"><![CDATA[<h2 id="motywacja">Motywacja</h2>
<p>Rozważmy następujący problem: błonę mydlaną rozpięliśmy między dwoma współosiowymi pierścieniami o promieniach $r_1$ i $r_2$. Wiadomo, że bańka mydlana przyjmuje zawsze taki kształt, aby jej pole powierzchni było jak najmniejsze - ten kształt chcemy znaleźć.</p>

<p>Bańkę mydlaną możemy traktować jak bryłę obrotową opisaną funkcją $f(x)$, przy czym $f(x_1)=r_1$ oraz $f(x_2)=r_2$.</p>
<p align="center">
<img src="/assets/images/2025-07-21/blona_mydlana.svg" width="600" />
</p>

<p>Aby policzyć powierzchnię bryły obrotowej, podzielmy ją na nieskończenie małe okręgi o promieniach $f(x)$ i o środkach na osi $x$. Obwód takiego okręgu to $2\pi f(x)$.</p>
<p align="center">
<img src="/assets/images/2025-07-21/bryla_obrotowa.svg" width="500" />
</p>
<p>Element powierzchni rozciągającej się między dwoma bliskimi okręgami to $2\pi f(x)\,dl$. Jak widać na rysunku, $dl=\sqrt{dx^2+(f’(x)\,dx)^2}=\sqrt{1+f’(x)^2}\,dx$. Zatem element powierzchni to $dS=2\pi f(x)\sqrt{1+f’(x)^2}\,dx$. Całkowita powierzchnia takiej bryły to wtedy
$$ S=2\pi\int_{x_1}^{x_2}f(x)\sqrt{1+f’(x)^2}\,dx.$$
Dążymy do zminimalizowania tej całki.</p>

<h2 id="wyprowadzenie-równania-eulera-lagrangea">Wyprowadzenie równania Eulera-Lagrange’a</h2>
<p>Rozważmy ogólniejszy przypadek. Chcemy zminimalizować całkę
$$ S=\int_{x_1}^{x_2}f(Y(x), Y’(x), x)\,dx. $$</p>

<p>Niech $y(x)$ będzie funkcją minimalizującą całkę $S$. Rozważmy funkcję $Y(x)=y(x)+\alpha \eta(x)$, gdzie $\eta(x)$ to dowolna funkcja, która spełnia warunek $\eta(x_1)=\eta(x_2)=0$. Wtedy $Y(x)$ spełnia te same warunki brzegowe co $y(x)$, lecz jest tą ,,mniej optymalną’’, w przypadku błony mydlanej powierzchnią między $x_1$ a $x_2$, czyli powierzchnia dla niej będzie nieco większa niż dla $y(x)$.</p>

<p>Spodziewamy się, że dla małych wartości $\alpha$, czyli małych odchyleń od optymalnej powierzchni, całka $S$ nie będzie ulegać zmianie (podobnie jest w przypadku zwykłych funkcji - gdy $f(x)$ ma minimum w $x_0$, $f’(x_0)=0$. Oznacza to, że w przybliżeniu dla małych $\varepsilon$ zachodzi $f(x_0+\varepsilon)-f(x_0)=f’(x_0)\varepsilon=0$). Innymi słowy
$$ \frac{\partial S}{\partial \alpha}=0. $$
Obliczmy tę pochodną:
$$ \frac{\partial S}{\partial \alpha}=\int_{x_1}^{x_2}\frac{\partial f}{\partial \alpha}\,dx$$
Z reguły łańcuchowej dla wielu zmiennych:
$$ \frac{\partial f}{\partial \alpha}=\frac{\partial f}{\partial Y}\frac{\partial Y}{\partial \alpha}+\frac{\partial f}{\partial Y’}\frac{\partial Y’}{\partial \alpha}+\frac{\partial f}{\partial x}\frac{\partial x}{\partial \alpha}   $$
Łatwo obliczyć, że $\partial Y/\partial \alpha=\eta(x)$, $\partial Y’/\partial \alpha=\eta’(x)$ oraz $\partial x/\partial\alpha=0$. Daje nam to
$$ \frac{\partial S}{\partial \alpha}=\int_{x_1}^{x_2}\left[\frac{\partial f}{\partial Y}\eta(x)+\frac{\partial f}{\partial Y’}\eta’(x)\right]\,dx $$
Aby zamienić $\eta’(x)$ na $\eta(x)$, pocałkujmy przez części:
$$ \int_{x_1}^{x_2}\frac{\partial f}{\partial Y’}\eta’(x)\,dx = \left[\eta(x)\frac{\partial f}{\partial Y’}\right]_{x_1}^{x_2}- \int_{x_1}^{x_2} \eta(x) \frac{d}{dx} \frac{\partial f}{\partial Y’}\,dx$$
Zauważmy, że ponieważ $\eta(x_1)=\eta(x_2)=0$, pierwszy wyraz z prawej strony się zeruje. To pozostawia nas z 
$$ \frac{\partial S}{\partial\alpha}=0=\int_{x_1}^{x_2}\eta(x)\left[ \frac{\partial f}{\partial Y}-\frac{d}{dx}\frac{\partial f}{\partial Y’} \right]\,dx$$
Skoro $\eta(x)$ to dowolna funkcja, wybierzmy $\eta(x)$ takie, że wyrażenie podcałkowe jest zawsze nieujemne. Skoro całka z nieujemnego wyrażenia jest równa $0$, to wyrażenie podcałkowe wynosi 0. Ponieważ $\eta(x)\neq 0$, 
$$ \frac{\partial f}{\partial y}-\frac{d}{dx}\frac{\partial f}{\partial y’} =0,$$
gdzie $Y$ zamieniłem na $y$, ponieważ jeżeli $Y$ spełnia powyższe równanie, jest ono ,,optymalną’’ funkcją. Jest to równanie Eulera-Lagrange’a.</p>

<h2 id="problem-błony-mydlanej">Problem błony mydlanej</h2>
<p>Powróćmy do wcześniejszego problemu. Doszliśmy do wniosku, że należy znaleźć funkcję $f(x)$, która minimalizuje całkę
$$ S=2\pi\int_{x_1}^{x_2}f(x)\sqrt{1+f’(x)^2}\,dx.$$
Niech $F(f(x), f’(x))=f(x)\sqrt{1+f’(x)^2}$. Wtedy równanie Eulera-Lagrange’a przyjmuje postać
$$ \frac{\partial F}{\partial f}-\frac{d}{dx}\frac{\partial F}{\partial f’} =0 $$</p>

<p>Zauważmy jednak, że $F(f(x), f’(x))$ nie zależy w jawny sposób od $x$. Pomnóżmy powyższe równanie przez $df/dx$:
$$ \frac{\partial F}{\partial f}\frac{df}{dx}-f’\frac{d}{dx}\frac{\partial F}{\partial f’}=0$$
Możemy obliczyć pierwszy wyraz po lewej stronie:
$$ \frac{\partial F}{\partial f}\frac{df}{dx}=\frac{dF}{dx}-\frac{\partial F}{\partial f’}\frac{df’}{dx}$$
i wstawić go spowrotem:
$$ \frac{dF}{dx}-\frac{\partial F}{\partial f’}\frac{df’}{dx}-f’\frac{d}{dx}\frac{\partial F}{\partial f’}=0 $$
Nietrudno zauważyć, że
$$-\frac{\partial F}{\partial f’}\frac{df’}{dx}-f’\frac{d}{dx}\frac{\partial F}{\partial f’}=-\frac{d}{dx}\left[f’\frac{\partial F}{\partial f’}\right] $$
czyli
$$  \frac{dF}{dx}-\frac{d}{dx}\left[f’\frac{\partial F}{\partial f’}\right]=0 $$
$$ \frac{d}{dx}\left[F-f’\frac{\partial F}{\partial f’}\right]=0 $$
$$ F-f’\frac{\partial F}{\partial f’}=const. $$</p>

<p>Ten rezultat możemy uogólnić. Jeśli $f(y(x), y’(x))$ nie zależy jawnie od $x$, to równanie Eulera-Lagrange’a sprowadza się do całki pierwszej:
$$ f-y’\frac{\partial f}{\partial y’}=const. $$</p>

<p>Wracając do problemu bańki mydlanej, mamy
$$ \frac{\partial F}{\partial f’}=f\frac{f’}{\sqrt{1+f’^2}} $$
Wstawmy to do całki pierwszej:
$$ f\sqrt{1+f’^2}-\frac{ff’^2}{\sqrt{1+f’^2}} = C $$
$$ f(1+f’^2)-ff’^2=C\sqrt{1+f’^2} $$
Dostajemy równanie różniczkowe 1 rzędu, które można rozwiązać za pomocą separacji zmiennych:
$$ f=C\sqrt{1+f’^2} $$
$$ 1+f’^2=Cf^2 $$
$$ \frac{df}{dx}=\sqrt{Cf^2-1} $$
$$ x+C_1=\int \frac{df}{\sqrt{C_2f^2-1} }$$
Całka po prawej stronie sprowadza się do $\frac{1}{C}\cosh^{-1}\left(Cf\right)$, a stąd
$$ f(x)=\frac{1}{C_1} \cosh (C_1 x+C_2), $$
gdzie $C_1$ i $C_2$ to pewne stałe.</p>

<h2 id="przypadek-wielu-zmiennych">Przypadek wielu zmiennych</h2>
<p>W przypadku, gdy $f=f(y_1, y_1’, y_2, y_2’, x)$, zapisujemy 2 równania Eulera-Lagrange’a, oddzielnie dla każdej zmiennej.
Jest tak, ponieważ jeśli rozważymy 2 funkcje 
$$ Y_1=y_1+\alpha\eta_1 $$
oraz
$$ Y_2=y_2+\beta\eta_2 $$
gdzie $\eta_1$ i $\eta_2$ spełniają takie warunki, jak wcześniejsze $\eta$, dostajemy 2 równania
$$ \frac{\partial S}{\partial \alpha}=0 $$
oraz 
$$ \frac{\partial S}{\partial \beta}=0. $$
W obu przypadkach zniknie albo $Y_1$ albo $Y_2$, co da nam 2 równania:
$$ \frac{\partial f}{\partial y_1}-\frac{d}{dx}\frac{\partial f}{\partial y_1’}=0 $$
$$ \frac{\partial f}{\partial y_2}-\frac{d}{dx}\frac{\partial f}{\partial y_2’}=0. $$
Wynik ten łatwo uogólnia się na większą liczbę zmiennych.</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Motywacja Rozważmy następujący problem: błonę mydlaną rozpięliśmy między dwoma współosiowymi pierścieniami o promieniach $r_1$ i $r_2$. Wiadomo, że bańka mydlana przyjmuje zawsze taki kształt, aby jej pole powierzchni było jak najmniejsze - ten kształt chcemy znaleźć.]]></summary></entry><entry><title type="html">Tworzenie prostej symulacji grawitacji w C++, część 2: Rysowanie kół, planety</title><link href="http://localhost:4000/programowanie/tworzenie%20prostej%20symulacji%20grawitacji%20w%20c++/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-2-rysowanie-k%C3%B3%C5%82-planety" rel="alternate" type="text/html" title="Tworzenie prostej symulacji grawitacji w C++, część 2: Rysowanie kół, planety" /><published>2025-07-13T00:00:00+02:00</published><updated>2025-07-13T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/tworzenie%20prostej%20symulacji%20grawitacji%20w%20c++/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-2-rysowanie-k%C3%B3%C5%82-planety</id><content type="html" xml:base="http://localhost:4000/programowanie/tworzenie%20prostej%20symulacji%20grawitacji%20w%20c++/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-2-rysowanie-k%C3%B3%C5%82-planety"><![CDATA[<h2 id="rysowanie-kół">Rysowanie kół</h2>
<p>Aby obserwować interakcję grawitacyjną, potrzebujemy obiekty, które będą w taki sposób oddziaływać. W tej symulacji będą one nazywane planetami, chociaż nie będą miały ściśle określonego przedziału na masę, gęstość i rozmiary. Będziemy je traktować jak kule, czyli w tym wypadku tak samo, jak masy punktowe. Aby reprezentować je na ekranie, będzie konieczna możliwość rysowania kół. Niestety SDL nie posiada funkcji wykonującej takie zadanie, więc trzeba ją stworzyć samodzielnie.</p>

<p>Wydajnym algorytmem do rysowania kół i okręgów jest <a href="https://en.wikipedia.org/wiki/Midpoint_circle_algorithm" target="_blank">algorytm midpoint</a>. Jego implementację dla SDL znalazłem <a href="https://gist.github.com/Gumichan01/332c26f6197a432db91cc4327fcabb1c" target="_blank">tutaj</a>.</p>

<p>W funkcji <code class="language-plaintext highlighter-rouge">draw()</code> przeniesionej do osobnego pliku dodałem następujące linijki rysujące okrąg i koło:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SDL_RenderDrawCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="n">SDL_RenderFillCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</code></pre></div></div>
<p>Rezultat jest następujący:</p>
<p align="center">
<img src="/assets/images/2025-07-13/okrag-i-kolo-test.png" width="500" />
</p>

<h2 id="planety">Planety</h2>
<h3 id="obiekt-planeta">Obiekt planeta</h3>
<p>W pliku <code class="language-plaintext highlighter-rouge">planet.h</code> utworzyłem klasę <code class="language-plaintext highlighter-rouge">Planet</code>, a w niej potrzebne zmienne i funkcje.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef PLANET_H
#define PLANET_H
</span><span class="k">class</span> <span class="nc">Planet</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="c1">// położenie planety</span>
        <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
        <span class="c1">// prędkość planety</span>
        <span class="kt">float</span> <span class="n">v_x</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">v_y</span><span class="p">;</span>
        <span class="c1">// masa planety</span>
        <span class="kt">float</span> <span class="n">mass</span><span class="p">;</span>
        <span class="c1">// gęstość planety</span>
        <span class="kt">float</span> <span class="n">density</span><span class="p">;</span>
        <span class="c1">// promień planety </span>
        <span class="kt">float</span> <span class="n">radius</span><span class="p">;</span>
        <span class="c1">// przyspieszenie planety</span>
        <span class="kt">float</span> <span class="n">a_x</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">a_y</span><span class="p">;</span>
        <span class="c1">// indentyfikator</span>
        <span class="kt">float</span> <span class="n">ID</span><span class="p">;</span>
        <span class="c1">// konstruktor</span>
        <span class="n">Planet</span><span class="p">(</span><span class="kt">float</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_v_x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_v_y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_mass</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_density</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_ID</span><span class="p">);</span>
        <span class="c1">// funkcja aktualizująca położenie planety</span>
        <span class="kt">void</span> <span class="n">updatePos</span><span class="p">();</span>
<span class="p">};</span>
<span class="cp">#endif
</span></code></pre></div></div>
<p>Identyfikator będzie potrzebny do obliczania przyspieszenia.</p>

<p>Następnie w pliku <code class="language-plaintext highlighter-rouge">planet.cpp</code> utworzyłem konstruktor, w którym obliczam promień na podstawie masy i gęstości ze wzoru
$$R = \left(\frac{3M}{4\pi\rho}\right)^{1/3}$$</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Planet</span><span class="o">::</span><span class="n">Planet</span><span class="p">(</span><span class="kt">float</span> <span class="n">_x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_v_x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_v_y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_mass</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_density</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_ID</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// przyporządkowujemy zmienne lokalne przekazane do konstruktora zmiennym globalnym 		</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_x</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">_y</span><span class="p">;</span>
    <span class="n">v_x</span> <span class="o">=</span> <span class="n">_v_x</span><span class="p">;</span>
    <span class="n">v_y</span> <span class="o">=</span> <span class="n">_v_y</span><span class="p">;</span>
    <span class="n">mass</span> <span class="o">=</span> <span class="n">_mass</span><span class="p">;</span>
    <span class="n">density</span> <span class="o">=</span> <span class="n">_density</span><span class="p">;</span>
    <span class="n">ID</span> <span class="o">=</span> <span class="n">_ID</span><span class="p">;</span> 
    <span class="n">a_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">a_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// R = [3M/(4*PI*rho)]^(1/3) dla jednorodnej kuli</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">pow</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="p">(</span><span class="mf">3.0f</span><span class="o">*</span><span class="n">mass</span><span class="o">/</span><span class="p">(</span><span class="mf">4.0f</span><span class="o">*</span><span class="mf">3.1415f</span><span class="o">*</span><span class="n">density</span><span class="p">)),</span> <span class="mx">0.333d</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>W funkcji <code class="language-plaintext highlighter-rouge">updatePos()</code> zaimplementowałem proste obliczanie kolejnych położeń i prędkości planety za pomocą algorytmu Eulera.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Planet</span><span class="o">::</span><span class="n">updatePos</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Planet</span><span class="o">&gt;</span> <span class="n">planets</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// OBLICZANIE POŁOŻENIA</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">v_x</span> <span class="o">*</span> <span class="n">dT</span><span class="p">;</span>
        <span class="c1">// dT to krok czasowy zdefiniowany w pliku main.h</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="n">v_y</span> <span class="o">*</span> <span class="n">dT</span><span class="p">;</span>

        <span class="c1">// OBLICZANIE PRĘDKOŚCI</span>
        <span class="c1">// musimy zresetować przyspieszenie, aby obliczyć je na nowo</span>
        <span class="n">a_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">a_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// obliczanie przyspieszenia ...</span>

        <span class="c1">// aktualizujemy prędkość</span>
        <span class="n">v_x</span> <span class="o">+=</span> <span class="n">a_x</span> <span class="o">*</span> <span class="n">dT</span><span class="p">;</span>
        <span class="n">v_y</span> <span class="o">+=</span> <span class="n">a_y</span> <span class="o">*</span> <span class="n">dT</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>$dT$ to pewien krok czasowy ustalony w pliku <code class="language-plaintext highlighter-rouge">main.h</code>. W przyszłości zostanie zaimplementowany algorytm Rungego-Kutty.</p>

<p>Ponieważ krok czasowy jest stały, w przypadku spowolnienia działania programu, zostanie również spowolniona symulacja. Rozważmy to na przykładzie. Załóżmy że program działa z szybkością 60 klatek na sekundę. Wtedy w ciągu sekundy przy kroku czasowym równym $1/60\text{s}$ symulacja postąpi o $1\text{s}$. Jeśli program będzie działał z szybkością 30 klatek na sekundę, aby w tym samym czasie symulacja postąpiła o czas $1\text{s}$, krok czasowy musiałby być 2 razy dłuższy.
Zostanie to w przyszłości naprawione implementując inną postać pętli programu.</p>

<h3 id="zarządzanie-planetami">Zarządzanie planetami</h3>
<p>Aby sprawnie zarządzać wszystkimi obiektami utworzyłem plik <code class="language-plaintext highlighter-rouge">handler.cpp</code>, którego zadaniem będzie aktualizowanie wszystkich planet. W nim utworzyłem wektor ze wszystkimi planetami i funkcję, która będzie je aktualizować.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">updatePlanets</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">planets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">updatePos</span><span class="p">();</span>	
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Warto zauważyć, że nie zadziała tutaj pętla for each, ponieważ tworzy ona nowe obiekty planet i aktualizuje parametry tych nowych, a nie już istniejących obiektów.</p>

<p>W pliku <code class="language-plaintext highlighter-rouge">main.cpp</code> utworzyłem funkcję:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setupEnvironment</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">planets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="n">Planet</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">5.47</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="n">planets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="n">Planet</span><span class="p">(</span><span class="mi">595</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="n">planets</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span> <span class="n">Planet</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.033</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div></div>
<p>oraz dodałem <code class="language-plaintext highlighter-rouge">updatePlanets()</code> z <code class="language-plaintext highlighter-rouge">handler.cpp</code> do pętli.</p>

<p>Należy pamiętać, aby wyświetlać planety na ekranie, dlatego zmodyfikowałem funkcję <code class="language-plaintext highlighter-rouge">draw()</code> w następujący sposób:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">SDL_Renderer</span><span class="o">*</span> <span class="n">renderer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ustal kolor tła i je zapełń</span>
    <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
    <span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>

    <span class="c1">// renderujemy po kolei wszystkie planety</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">planets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
        <span class="n">SDL_RenderFillCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">100</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// wyświetl to, co zostało narysowane </span>
    <span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="interakcja-grawitacyjna">Interakcja grawitacyjna</h3>
<p>Potrzebujemy w funkcji <code class="language-plaintext highlighter-rouge">updatePlanets()</code> dostęp do wektora <code class="language-plaintext highlighter-rouge">planets</code>, więc będzie on przekazywany jako argument tej funkcji. Następnie utwórzmy w niej pętlę sumującą przyspieszenia pochodzące od wszystkich innych planet, aby obliczyć siłę wypadkową. Oczywiście musimy sumować rzuty przyspieszeń na poszczególne osie.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">planets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">ID</span> <span class="o">!=</span> <span class="n">ID</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// nie chcemy żeby planeta przyciągała sama siebie</span>
        <span class="c1">// obliczamy r^2</span>
        <span class="kt">float</span> <span class="n">distance_squared</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">y</span><span class="p">);</span>
        <span class="c1">// obliczamy wartość przyspieszenia</span>
        <span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">*</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">mass</span><span class="o">/</span><span class="n">distance_squared</span><span class="p">;</span>
        <span class="c1">// obliczamy wartość sinusa i cosinusa kąta między planetami</span>
        <span class="kt">float</span> <span class="n">cos</span> <span class="o">=</span> <span class="p">(</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">x</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">pow</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">distance_squared</span><span class="p">,</span> <span class="mx">0.5d</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">sin</span> <span class="o">=</span> <span class="p">(</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">y</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">pow</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">distance_squared</span><span class="p">,</span> <span class="mx">0.5d</span><span class="p">);</span>
        <span class="c1">// dodajemy składowe przyspieszenia</span>
        <span class="n">a_x</span> <span class="o">+=</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">;</span>
        <span class="n">a_y</span> <span class="o">+=</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="poruszanie-kamerą">Poruszanie kamerą</h2>
<p>Planety mogą szybko uciec z pola widzenia, dlatego ważna jest możliwość poruszania kamerą.</p>

<p>Utworzyłem tablicę boolów <code class="language-plaintext highlighter-rouge">keysDown</code> o 4 elementach, które opisują stan wciśnięcia strzałek na klawiaturze. Są one ustalane w funkcji <code class="language-plaintext highlighter-rouge">handleEvents()</code> w <code class="language-plaintext highlighter-rouge">main.cpp</code>. Na ich podstawie mogę zmieniać aktualną prędkość i położenie kamery:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">updateCam</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ustawiamy prędkość kamery na postawie wciśniętych klawiszy</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">keysDown</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cam_vy</span> <span class="o">=</span> <span class="o">-</span><span class="n">cam_v</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">keysDown</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cam_vy</span> <span class="o">=</span> <span class="n">cam_v</span><span class="p">;</span>
    <span class="k">else</span> 
        <span class="n">cam_vy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">keysDown</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">cam_vx</span> <span class="o">=</span> <span class="n">cam_v</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">keysDown</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">cam_vx</span> <span class="o">=</span> <span class="o">-</span><span class="n">cam_v</span><span class="p">;</span>
    <span class="k">else</span> 
        <span class="n">cam_vx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// aktualizujemy położenie kamery</span>
    <span class="n">cam_x</span> <span class="o">+=</span> <span class="n">cam_vx</span><span class="p">;</span>
    <span class="n">cam_y</span> <span class="o">+=</span> <span class="n">cam_vy</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">cam_v</code> to pewna odgórnie ustalona (później dostępna do regulacji dla użytkownika) prędkość kamery.
Aby zmiana położenia kamery miała efekt, jej położenie musimy odjąć od położenia planet:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SDL_RenderFillCircle</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">x</span> <span class="o">-</span> <span class="n">cam_x</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">y</span> <span class="o">-</span> <span class="n">cam_y</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">planets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">100</span><span class="p">));</span>
</code></pre></div></div>
<p>Dlaczego tak jest? Załóżmy, że planeta jest w pozycji $(200, 200)$, a kamera w pozycji $(100, 100)$. Oznacza to, że planeta jest o $100$ pikseli niżej i o $100$ pikseli na prawo od kamery. Położenie planety na ekranie powinno zatem wynosić $(100, 100)$, a więc $(200, 200)-(100,100)$.</p>

<p>W chwili obecnej program prezentuje się następująco:</p>
<p align="center">
<img src="/assets/images/2025-07-13/dzialanie-programu.gif" width="500" />
</p>

<p>W następnej części zostanie zaimplementowana ulepszona pętla programu oraz algorytm Rungego-Kutty do obliczania trajektorii planet. Kod źródłowy projektu jest dostępny na <a href="https://github.com/bwegrzyn0/grav-sim" target="_blank">GitHub</a>.</p>]]></content><author><name></name></author><category term="Programowanie" /><category term="Tworzenie prostej symulacji grawitacji w C++" /><summary type="html"><![CDATA[Rysowanie kół Aby obserwować interakcję grawitacyjną, potrzebujemy obiekty, które będą w taki sposób oddziaływać. W tej symulacji będą one nazywane planetami, chociaż nie będą miały ściśle określonego przedziału na masę, gęstość i rozmiary. Będziemy je traktować jak kule, czyli w tym wypadku tak samo, jak masy punktowe. Aby reprezentować je na ekranie, będzie konieczna możliwość rysowania kół. Niestety SDL nie posiada funkcji wykonującej takie zadanie, więc trzeba ją stworzyć samodzielnie.]]></summary></entry><entry><title type="html">Tworzenie prostej symulacji grawitacji w C++, część 1: SDL2</title><link href="http://localhost:4000/programowanie/tworzenie%20prostej%20symulacji%20grawitacji%20w%20c++/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-1-sdl2" rel="alternate" type="text/html" title="Tworzenie prostej symulacji grawitacji w C++, część 1: SDL2" /><published>2025-07-06T00:00:00+02:00</published><updated>2025-07-06T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/tworzenie%20prostej%20symulacji%20grawitacji%20w%20c++/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-1-sdl2</id><content type="html" xml:base="http://localhost:4000/programowanie/tworzenie%20prostej%20symulacji%20grawitacji%20w%20c++/tworzenie-prostej-symulacji-grawitacji-w-cpp-cz%C4%99%C5%9B%C4%87-1-sdl2"><![CDATA[<h2 id="cel-projektu">Cel projektu</h2>
<p>Celem tego projektu jest stworzenie programu w C++, który będzie pozwalał użytkownikowi:</p>
<ul>
  <li>dodawać do sceny ciała niebieskie, które będą oddziaływać ze sobą grawitacyjnie</li>
  <li>modyfikować ich parametry, takie jak masa, prędkość, położenie, jasność itd. za pomocą prostego interfejsu</li>
  <li>pauzować, przyspieszać, cofać, resetować symulację</li>
  <li>poruszać się kamerą po scenie za pomocą myszki, przybliżać i oddalać widok</li>
  <li>wykreślać i przewidywać trajektorie obiektów</li>
  <li>ustalać punkt odniesienia dla trajektorii</li>
  <li>zablokować widok na jednym obiekcie.</li>
</ul>

<p>Program ma spełniać również następujące założenia:</p>
<ul>
  <li>ruch planet ma być dokładnie obliczany za pomocą algorytmu Rungego-Kutty (opisanego w <a href="/programowanie/numeryczne-rozwiązywanie-równań-różniczkowych-2-rzędu-metodą-rungego-kutty" target="_blank">tym</a> artykule)</li>
  <li>program ma być zoptymalizowany</li>
  <li>ruch będzie odbywał się w jednej płaszczyźnie i przedstawiany będzie widok z góry</li>
  <li>oświetlenie planet, zaćmienia (gdy jedna planeta przechodzi za drugą)</li>
  <li>planety będą przedstawiane jako koła o różnych kolorach</li>
  <li>anti-aliasing planet</li>
  <li>zarządzanie obiektami w kodzie powinno być łatwe i uporządkowane.</li>
</ul>

<h2 id="kod-źródłowy">Kod źródłowy</h2>
<p>Kod źródłowy projektu jest dostępny w <a href="https://github.com/bwegrzyn0/grav-sim" target="_blank">repozytorium GitHub</a>.</p>

<h2 id="wyświetlanie-okna---sdl2">Wyświetlanie okna - SDL2</h2>
<p>Do wyświetlania okna i rysowania na nim w tym projekcie użyłem bibliotekę <a href="https://www.libsdl.org/" target="_blank">SDL2</a>. Dobry poradnik, jak ją używać, można znaleźć <a href="https://lazyfoo.net/tutorials/SDL/index.php" target="_blank">tutaj</a>.</p>

<h3 id="inicjalizacja-sdl">Inicjalizacja SDL</h3>
<p>W pliku <code class="language-plaintext highlighter-rouge">main.cpp</code> dodałem bibliotekę SDL2:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;SDL2/SDL.h&gt;</span><span class="cp">
</span></code></pre></div></div>
<p>a następnie utworzyłem zmienne i obiekty:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// wymiary okna</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>

<span class="c1">// okno</span>
<span class="n">SDL_Window</span><span class="o">*</span> <span class="n">window</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="c1">// renderer</span>
<span class="n">SDL_Renderer</span><span class="o">*</span> <span class="n">renderer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>
<p>Obiekt <code class="language-plaintext highlighter-rouge">renderer</code> będzie odpowiedzialny za rysowanie pikseli w oknie <code class="language-plaintext highlighter-rouge">window</code>. Stworzyłem funkcję inicjalizującą SDL:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja odpowiadająca za inicjalizację SDL</span>
<span class="kt">bool</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="c1">// inicjalizuj SDL</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Could not init SDL: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
		<span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// utwórz okno</span>
		<span class="n">window</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span><span class="s">"grav-sim"</span><span class="p">,</span> <span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span> <span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">SDL_WINDOW_SHOWN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">window</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"Could not create window: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
			<span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// stwórz renderer</span>
			<span class="n">renderer</span> <span class="o">=</span> <span class="n">SDL_CreateRenderer</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">SDL_RENDERER_ACCELERATED</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">renderer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"Could not create renderer: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
				<span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Jeśli inicjalizacja nie przebiegnie pomyślnie, funkcja zwróci <code class="language-plaintext highlighter-rouge">false</code>. Potrzebna jest również funkcja “sprzątająca” po wszystkim:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja odpowiadająca za "posprzątanie" po wszystkim</span>
<span class="kt">void</span> <span class="nf">close</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// zniszcz okno, zwolnij miejsce w pamięci, zamknij SDL</span>
	<span class="n">SDL_DestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
	<span class="n">window</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">SDL_Quit</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="rejestrowanie-wejścia-od-użytkownika">Rejestrowanie wejścia od użytkownika</h3>
<p>W tym celu utworzyłem obiekt <code class="language-plaintext highlighter-rouge">SDL_Event</code>, który będzie wykrywał zdarzenia, takie jak wciśnięcie klawiatury, myszki itd. oraz funkcję, która na podstawie wykrytego zdarzenia wypisze informację do konsoli:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">running</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">SDL_Event</span> <span class="n">event</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">handleEvents</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">SDL_PollEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// funkcja sprawdzająca zdarzenia</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// typ zdarzenia</span>
            <span class="k">case</span> <span class="n">SDL_KEYDOWN</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Key press</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">// wciśnięcie klawisza na klawiaturze</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">SDL_KEYUP</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Key up</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> <span class="c1">// puszczenie klawisza na klawiaturze</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">SDL_QUIT</span><span class="p">:</span>
                <span class="n">running</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// zamknięcie okna</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Quitting</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="nl">default:</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Zmienna <code class="language-plaintext highlighter-rouge">running</code> mówi, czy program jest uruchomiony. Przyda się ona w jednym z kolejnych kroków.</p>

<h3 id="rysowanie">Rysowanie</h3>
<p>Utworzyłem funkcję, która będzie odpowiedzialna za rysowanie na ekranie. Dodałem w niej również rysowanie białego prostokąta:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">draw</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span> <span class="c1">// ustawiamy kolor tła (RGBA)</span>
	<span class="n">SDL_RenderClear</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span> <span class="c1">// zapełniamy tło</span>

	<span class="n">SDL_Rect</span> <span class="n">rect</span><span class="p">;</span> <span class="c1">// tworzymy nowy obiekt typu prostokąt</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// ustalamy jego położenie i rozmiary</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">rect</span><span class="p">.</span><span class="n">h</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">SDL_SetRenderDrawColor</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// ustawiamy kolor prostokąta</span>
	<span class="n">SDL_RenderFillRect</span><span class="p">(</span><span class="n">renderer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rect</span><span class="p">);</span> <span class="c1">// rysujemy wypełniony prostokąt</span>

	<span class="n">SDL_RenderPresent</span><span class="p">(</span><span class="n">renderer</span><span class="p">);</span> <span class="c1">// wyświetlamy obraz na ekranie</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pętla-programu">Pętla programu</h3>
<p>Utworzyłem funkcję zawierającą główną pętlę programu:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">handleEvents</span><span class="p">();</span>
		<span class="n">draw</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Na razie kod jest uruchamiany w pętli while, czyli jak najszybciej jest to możliwe. Jest to oczywiście nieopłacalne i niestabilne. Zostanie to naprawione później.</p>

<p>Tak wygląda moja funkcja <code class="language-plaintext highlighter-rouge">main()</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">loop</span><span class="p">();</span>
	<span class="n">close</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="co-dalej">Co dalej?</h2>
<p>Powyższy program wyświetla okno, a w nim biały prostokąt na czerwonym tle. W następnej części opiszę proces rysowania kół i okręgów za pomocą algorytmu midpoint oraz to, jak dodałem planety.</p>]]></content><author><name></name></author><category term="Programowanie" /><category term="Tworzenie prostej symulacji grawitacji w C++" /><summary type="html"><![CDATA[Cel projektu Celem tego projektu jest stworzenie programu w C++, który będzie pozwalał użytkownikowi: dodawać do sceny ciała niebieskie, które będą oddziaływać ze sobą grawitacyjnie modyfikować ich parametry, takie jak masa, prędkość, położenie, jasność itd. za pomocą prostego interfejsu pauzować, przyspieszać, cofać, resetować symulację poruszać się kamerą po scenie za pomocą myszki, przybliżać i oddalać widok wykreślać i przewidywać trajektorie obiektów ustalać punkt odniesienia dla trajektorii zablokować widok na jednym obiekcie.]]></summary></entry><entry><title type="html">Numeryczne rozwiązywanie równań różniczkowych 2 rzędu za pomocą algorytmu Rungego-Kutty</title><link href="http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty" rel="alternate" type="text/html" title="Numeryczne rozwiązywanie równań różniczkowych 2 rzędu za pomocą algorytmu Rungego-Kutty" /><published>2025-06-30T00:00:00+02:00</published><updated>2025-06-30T00:00:00+02:00</updated><id>http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty</id><content type="html" xml:base="http://localhost:4000/programowanie/numeryczne-rozwi%C4%85zywanie-r%C3%B3wna%C5%84-r%C3%B3%C5%BCniczkowych-2-rz%C4%99du-metod%C4%85-rungego-kutty"><![CDATA[<h2 id="algorytm-rungego-kutty">Algorytm Rungego-Kutty</h2>
<p>Mamy dane równanie różniczkowe 1 rzędu w postaci
$$ \frac{dy}{dx}=f(x,y). $$
Najprostszą metodą, aby rozwiązać tego typu równanie numerycznie jest metoda Eulera. Pochodną możemy przybliżyć jako
$$ \frac{dy}{dx}\approx\frac{y(x+\Delta x)-y(x)}{\Delta x}, $$
a stąd
$$ y(x+\Delta x)\approx y(x)+\Delta x f(x,y). $$
Metoda ta jest bardzo niedokładna szczególnie dla rozwiązań oscylujących. Jest ona również nazywana algorytmem Rungego-Kutty 1 rzędu.</p>

<p>O wiele lepsze przybliżenie daje algorytm Rungego-Kutty 4 rzędu. W pierwszej kolejności należy obliczyć 4 wielkości:
$$ k_1=f(x,y) $$
$$ k_2=f(x+\frac{\Delta x}{2}, y+\frac{\Delta x}{2}k_1) $$
$$ k_3=f(x+\frac{\Delta x}{2}, y+\frac{\Delta x}{2}k_2) $$
$$ k_4=f(x+\Delta x, y+\Delta x\,k_3), $$
a następnie możemy obliczyć wartość szukanej funkcji w kolejnym kroku:
$$ y(x+\Delta x)\approx y(x)+\frac{\Delta x}{6}(k_1+2k_2+2k_3+k_4). $$</p>
<h3 id="przykład">Przykład</h3>
<p>Rozważmy równanie nieliniowe
$$ \frac{dy}{dx}=y\cos x$$
z warunkiem początkowym $ y(0)=1 $. Łatwo jest sprawdzić, że jego rozwiązaniem jest $ y=e^{\sin x}$.</p>

<p>Program rozwiązujący to równanie numerycznie został napisany w C++.</p>

<p>W pierwszej kolejności definiujemy zmienne i warunki początkowe:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// ustawiamy y na wartość początkową</span>
<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// ustawiamy x na wartość początkową</span>
<span class="kt">float</span> <span class="n">x_max</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> <span class="c1">// końcowa wartość x</span>
<span class="kt">float</span> <span class="n">step</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// krok - Delta x</span>
</code></pre></div></div>

<p>Następnie zdefiniujmy naszą funkcję $f(x,y)$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">dy_dx</span><span class="p">(</span><span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Teraz musimy wykonać <code class="language-plaintext highlighter-rouge">(x_max-x_min)/step</code> kroków, a w każdym z nich wykonać procedurę opisaną na początku artykułu:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">x_max</span><span class="o">-</span><span class="n">x_min</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">float</span> <span class="n">k_1</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_2</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">k_1</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_3</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
		<span class="kt">float</span> <span class="n">k_4</span> <span class="o">=</span> <span class="n">dy_dx</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">step</span><span class="o">*</span><span class="n">k_3</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">step</span><span class="p">);</span>

		<span class="n">x</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span> <span class="c1">// zwiększamy x o jeden krok</span>
		<span class="n">y</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3</span><span class="o">+</span><span class="n">k_4</span><span class="p">);</span> <span class="c1">// obliczamy y(x+Delta x)</span>
		<span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// zapisujemy wynik do pliku </span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wyniki zapisałem do pliku <code class="language-plaintext highlighter-rouge">.csv</code>, a następnie naniosłem w pythonie na widoczny poniżej wykres:</p>

<p align="center">
<img src="/assets/images/2025-06-30/przyklad1.svg" width="500" />
</p>
<p>Czerwona linia przedstawia rozwiązanie analityczne, a niebieskie krzyżyki rozwiązanie numeryczne. Widzimy, że algorytm Rungego-Kutty 4 rzędu nawet przy dużych wartościach $ \Delta x $ daje bardzo dobre rezultaty.</p>

<h2 id="równanie-różniczkowe-2-rzędu-jako-układ-równań-1-rzędu">Równanie różniczkowe 2 rzędu jako układ równań 1 rzędu</h2>
<p>Niech będzie dane równanie różniczkowe 2 rzędu:
$$ \frac{d^2 y}{dx^2}=f(x, y, y’). $$
Podstawienie $ u=y’ $ daje nam układ równań pierwszego rzędu
$$
\begin{cases} u’ = f(x, y, u) \\ u=y’=g(x,y,u) \end{cases} 
$$</p>

<h3 id="przykład-1">Przykład</h3>
<p>Rozważmy równanie ruchu tłumionego oscylatora harmonicznego:
$$ \ddot{x}+2\beta m\dot{x}+\omega_0^2 x = 0. $$
Podstawienie $v=\dot{x}$ daje nam układ równań
$$
\begin{cases} \dot{v}=-2\beta v-\omega_0^2 x \\ v=\dot{x}  \end{cases}
$$</p>

<h2 id="numeryczne-rozwiązywanie-równań-2-rzędu">Numeryczne rozwiązywanie równań 2 rzędu</h2>
<p>Aby numerycznie rozwiązać równanie 2 rzędu musimy mieć dane $y(x_0)$ oraz $u(x_0)$, gdzie $x_0$ to pewna wartość początkowa zmiennej.</p>

<p>W pierwszej kolejności obliczamy $k_1$ dla obydwu równań:
$$ k_{1y}=g(x, y, u), $$
gdzie $g(x, y, u)=u$.
$$ k_{1u}=f(x, y, u) $$
Aby obliczyć $k_{2y}$, za $u$ podstawiamy $u+k_{1u}\Delta x/2$:
$$ k_{2y}=g(x+\frac{\Delta x}{2}, y+k_{1y}\frac{\Delta x}{2}, u+k_{1u}\frac{\Delta x}{2}) $$
i podobnie obliczamy $k_{2u}$:
$$ k_{2u}=f(x+\frac{\Delta x}{2}, y+k_{1y}\frac{\Delta x}{2}, u+k_{1u}\frac{\Delta x}{2}). $$
Prodecura wygląda analogicznie dla $k_3$ i $k_4$. Finalnie możemy obliczyć $y(x+\Delta x)$:
$$ y(x+\Delta x)=y(x)+\frac{\Delta x}{6}(k_{1y}+2k_{2y}+2k_{3y}+k_{4y}) $$
i analogicznie $u$.</p>

<h3 id="przykład-2">Przykład</h3>
<p>Rozważmy wcześniejsze równanie ruchu tłumionego oscylatora harmonicznego z warunkami początkowymi $x(0)=0$ i $v(0)=1$ oraz parametrami $\omega_0=2$, $\beta=0.5$, $m=1$.</p>

<p>Zdefiniujmy zmienne i warunki początkowe:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// warunki początkowe</span>
<span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t_min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t_min</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">t_max</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// jak daleko ma sięgać symulacja</span>
<span class="kt">float</span> <span class="n">step</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span> <span class="c1">// Delta x</span>
<span class="c1">// parametry układu</span>
<span class="kt">float</span> <span class="n">omega_0</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</code></pre></div></div>
<p>Następnie zdefiniujmy funkcje $f(x)$ i $g(x)$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja obliczająca dv/dt</span>
<span class="kt">float</span> <span class="nf">f</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">v</span><span class="o">-</span><span class="n">omega_0</span><span class="o">*</span><span class="n">omega_0</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// funkcja obliczająca dx/dt</span>
<span class="kt">float</span> <span class="nf">g</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Utwórzmy funkcję, która oblicza kolejne wartości $x$ i $v$:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// funkcja obliczająca następną wartość x  z użyciem metody Rungego-Kutty</span>
<span class="kt">void</span> <span class="nf">next</span><span class="p">(</span><span class="kt">float</span> <span class="n">t</span><span class="p">,</span> <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// obliczamy wszystkie k dla obu równań</span>
	<span class="kt">float</span> <span class="n">k_1x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_1v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_2x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_1x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_1v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_2v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_1x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_1v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_3x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_2x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_2v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_3v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_2x</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_2v</span><span class="o">*</span><span class="n">step</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

	<span class="kt">float</span> <span class="n">k_4x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_3x</span><span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_3v</span><span class="o">*</span><span class="n">step</span><span class="p">);</span>
	<span class="kt">float</span> <span class="n">k_4v</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">k_3x</span><span class="o">*</span><span class="n">step</span><span class="p">,</span> <span class="n">v</span><span class="o">+</span><span class="n">k_3v</span><span class="o">*</span><span class="n">step</span><span class="p">);</span>
	
	<span class="c1">// obliczamy kolejne wartości dla x oraz v</span>
	<span class="o">::</span><span class="n">x</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2x</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3x</span><span class="o">+</span><span class="n">k_4x</span><span class="p">);</span>
	<span class="o">::</span><span class="n">v</span> <span class="o">+=</span> <span class="n">step</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">k_1v</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_2v</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">k_3v</span><span class="o">+</span><span class="n">k_4v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Należy pamiętać, aby również obliczać kolejne wartości dla $v$, ponieważ w przeciwnym razie pochodna będzie cały czas stała. Możemy teraz utworzyć pętlę w funkcji <code class="language-plaintext highlighter-rouge">main()</code>:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">t_max</span><span class="o">-</span><span class="n">t_min</span><span class="p">)</span><span class="o">/</span><span class="n">step</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">step</span><span class="p">;</span>
    <span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span>  <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// zapisujemy wyniki do pliku</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Podobnie jak wcześniej wyniki oraz rozwiązanie analityczne naniosłem na jeden wykres, otrzymując idealną zgodność:</p>
<p align="center">
<img src="/assets/images/2025-06-30/przyklad2.svg" width="500" />
</p>

<p>Pełne pliki źródłowe są dostępne do pobrania tutaj: <br />
<a href="/assets/downloads/2025-06-30/przykład1.cpp" target="_blank">przykład1.cpp</a> <br />
<a href="/assets/downloads/2025-06-30/przykład2.cpp" target="_blank">przykład2.cpp</a></p>

<h2 id="uogólnienie-na-równania-wyższych-rzędów">Uogólnienie na równania wyższych rzędów</h2>
<p>W takim przypadku ponownie rozpisujemy równanie $n$-tego rzędu jako układ $n$ równań różniczkowych 1 rzędu, np.
$$
\begin{cases} \dot{x_1}=f_1(t, x_1, x_2, \dots, x_n) \\ \dot{x_2}=f_2(t, x_1, x_2, \dots, x_n) \\ \dots \\ \dot{x_n}=f_n(t, x_1, x_2, \dots, x_n) \end{cases}
$$
Niech $\mathbf{x}=(x_1,x_2,\dots,x_n)^\intercal$ oraz $\mathbf{f}(t, \mathbf{x})=(f_1(t, \mathbf{x}), f_2(t, \mathbf{x}), \dots, f_n(t, \mathbf{x}))^\intercal$. Wtedy układ równań możemy zapisać jako 
$$ \dot{\mathbf{x}}=\mathbf{f}(t, \mathbf{x}) $$
Obliczamy teraz $\mathbf{k_1}, \mathbf{k_2}, \dots$:
$$ \mathbf{k_1}=\mathbf{f}(t, \mathbf{x}) $$
$$ \mathbf{k_2}=\mathbf{f}(t+\frac{\Delta t}{2}, \mathbf{x}+\mathbf{k_1}\frac{\Delta t}{2}) $$
itd.
W przypadku $n=2$ wszystko sprowadza się do opisanego wcześniej algorytmu.</p>]]></content><author><name></name></author><category term="Programowanie" /><summary type="html"><![CDATA[Algorytm Rungego-Kutty Mamy dane równanie różniczkowe 1 rzędu w postaci $$ \frac{dy}{dx}=f(x,y). $$ Najprostszą metodą, aby rozwiązać tego typu równanie numerycznie jest metoda Eulera. Pochodną możemy przybliżyć jako $$ \frac{dy}{dx}\approx\frac{y(x+\Delta x)-y(x)}{\Delta x}, $$ a stąd $$ y(x+\Delta x)\approx y(x)+\Delta x f(x,y). $$ Metoda ta jest bardzo niedokładna szczególnie dla rozwiązań oscylujących. Jest ona również nazywana algorytmem Rungego-Kutty 1 rzędu.]]></summary></entry><entry><title type="html">Wyznaczanie gęstości powietrza za pomocą wahadła matematycznego</title><link href="http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego" rel="alternate" type="text/html" title="Wyznaczanie gęstości powietrza za pomocą wahadła matematycznego" /><published>2025-06-18T00:00:00+02:00</published><updated>2025-06-18T00:00:00+02:00</updated><id>http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego</id><content type="html" xml:base="http://localhost:4000/mechanika/wyznaczanie-g%C4%99sto%C5%9Bci-powietrza-za-pomoc%C4%85-wahad%C5%82a-matematycznego"><![CDATA[<h2 id="tłumione-wahadło-matematyczne">Tłumione wahadło matematyczne</h2>
<p>Rozważmy najprostszy model wahadła. Jest to masa punktowa $m$ zawieszona na nieważkiej lince o długości $l$. Na wahadło działa siła ciężkości $\mathbf{Q}$, która rozkłada się na składową radialną i styczną do linki oraz siła reakcji linki $\mathbf{F_r}$, która równoważy $\mathbf{Q_r}$. Na masę działa również siła oporu $\mathbf{F_o}$. Poniżej został przedstawiony schemat tego układu.</p>

<p align="center">
<img src="/assets/images/2025-06-18/wahadlotlumione.svg" width="500" />
</p>

<p>Przy małych prędkościach wartość siły oporu $\mathbf{F_o}$  działającej na naszą masę jest wprost proporcjonalna do prędkości tego ciała. Dlatego założymy, że nasze wahadło porusza się z niewielką prędkością. Pozwoli nam to zapisać 2 zasadę dynamiki jako
$$ \mathbf{M}=\mathbf{l}\times\mathbf{Q_s}+\mathbf{l}\times\mathbf{F_o}, $$
gdzie $\mathbf{l}$ to wektor łączący punkt zaczepienia wahadła i masę $m$.</p>

<p>Niech $\hat{\mathbf{n}}$ będzie wektorem jednostkowym leżącym na tym samym kierunku co $\mathbf{Q_s}$ i o zwrocie w lewo. Wtedy $\mathbf{Q_s}=Q_s\hat{\mathbf{n}}$. Wiadomo, że $Q_s=Q\sin\theta=mg\sin\theta$, czyli $\mathbf{Q_s}=mg\sin\theta\,\hat{\mathbf{n}}$. Wtedy $\mathbf{l}\times\mathbf{Q_s}=mg\sin\theta\,\mathbf{l}\times\hat{\mathbf{n}}$. Łatwo zauważyć, że $\mathbf{l}\times\hat{\mathbf{n}}=-l\hat{\mathbf{k}}$, przy czym oś $z$ jest skierowana od ekranu. Zatem $\mathbf{l}\times\mathbf{Q_s}=-mgl\sin\theta\,\hat{\mathbf{k}}$.</p>

<p>Jak wspomniano wcześniej, $\mathbf{F_o}=-2\beta m\mathbf{v}$, gdzie $\beta$ to pewna stała - współczynnik tłumienia, a czynnik $2m$ ułatwi późniejsze obliczenia. Wiemy, że $\mathbf{v}=\boldsymbol{\dot{\theta}}\times\mathbf{l}$, a $\boldsymbol{\dot{\theta}}=\dot{\theta}\hat{\mathbf{k}}$. Na podstawie reguły prawej ręki możemy stwierdzić, że $\mathbf{v}=-\dot{\theta}l\hat{\mathbf{n}}$, a co za tym idzie $\mathbf{F_o}=2\beta ml\dot{\theta}\,\hat{\mathbf{n}}$. Teraz możemy obliczyć moment siły oporów:
$$ \mathbf{l}\times\mathbf{F_o}=2\beta ml\dot{\theta}\,{\mathbf{l}}\times\hat{\mathbf{n}}=-2\beta ml^2\dot{\theta}\,\hat{\mathbf{k}}.$$</p>

<p>Wiemy również, że $\mathbf{M}=I\ddot{\theta}\hat{\mathbf{k}}$, gdzie $I$ to moment bezwładności wahadła wokół punktu zaczepienia. Dla masy punktowej będzie to $ml^2$. Możemy teraz zapisać 2 zasadę dynamiki jako
$$ ml^2\ddot{\theta}\hat{\mathbf{k}}=-mgl\sin{\theta}\,\hat{\mathbf{k}}-2\beta ml^2\dot{\theta}\,\hat{\mathbf{k}}, $$
a po podzieleniu przez $ml^2\hat{\mathbf{k}}$ otrzymamy
$$ \ddot{\theta}+2\beta\dot{\theta}+\frac{g}{l}\sin{\theta}=0. $$
Gdy $\theta$ jest małym kątem, zachodzi w przybliżeniu równość $\sin\theta\approx\theta$, co pozwala nam zapisać 
$$ \ddot{\theta}+2\beta\dot{\theta}+\omega_0^2\theta=0, $$
gdzie $\omega_0=\sqrt{g/l}$.</p>

<p>Równanie charakterystyczne to
$$ r^2+2\beta r+\omega_0^2=0, $$
a jego rozwiązania to
$$ r=-\beta\pm i\omega, $$
gdzie $\omega=\sqrt{\omega_0^2-\beta^2}$. Rozwiązanie ogólne to wtedy
$$ \theta=e^{-\beta t}\left(Ae^{i\omega}+Be^{-i\omega}\right), $$
gdzie $A$ i $B$ to pewne stałe. Zapis ten jest równoważny
$$ \theta=e^{-\beta t}\left[(A+B)\cos\omega t+(A-B)i\sin\omega t\right]. $$
$\theta$ musi być liczbą rzeczywistą, dlatego $B=\overline{A}$. Niech $A=a+bi$, wtedy $B=a-bi$. Wstawiając to do powyższego równania otrzymamy
$$ \theta=e^{-\beta t}\left(2a\cos\omega t-2b\sin\omega t\right). $$
Ponieważ w nawiasie znajduje się liniowa kombinacja sinusa i cosinusa, możemy zapisać
$$ \theta=\theta_0 e^{-\beta t}\cos(\omega t+\varphi), $$
gdzie $\theta_0$ to amplituda drgań, a $\varphi$ to faza.</p>

<h2 id="pomiar-współczynnika-tłumienia">Pomiar współczynnika tłumienia</h2>
<p>Skonstruowano wahadło z cienkiej, w przybliżeniu nieważkiej nitki oraz śruby zamocowanej na jej końcu. Ponieważ rozmiary śruby były znacznie mniejsze niż długość wahadła, cała masa była w przybliżeniu skoncentrowana w jednym punkcie. Nitka została owinięta wokół cienkiego patyczka służącego jako punkt zaczepienia. Taki sposób zaczepienia linki umożliwił łatwą regulację długości wahadła. Zakładamy, że współczynnik tłumienia jest na tyle mały, że $\omega\approx\omega_0$.</p>

<p>Mierząc wartość $\theta$, gdy $\cos(\omega t+\varphi)=1$ (gdy wahadło jest w swoim maksymalnym wychyleniu) możemy wyznaczyć $\beta$. Czas mierzymy od chwili puszczenia wahadła, więc $\varphi=0$. Warunek zachodzi w bardzo dobrym przybliżeniu dla małych wychyleń (ponieważ $T$ tak naprawdę zależy od amplitudy), gdy $t=nT$, gdzie $T$ to okres wahadła, a $n=0,1,2,\dots$.
$$		\theta(nT)=\theta_0 e^{-\beta nT} $$
$$		\ln{\theta(nT)}=\ln{\theta_0}+-\beta nT $$
Sporządzając wykres $\ln{\theta(nT)}$ możemy wyznaczyć $\beta$ nawet bez znajomości $\theta_0$, ponieważ będzie to współczynnik kierunkowy prostej najlepszego dopasowania.</p>

<p>Wahadło zostało umieszczone w odległości $d=2$cm od biurka, do którego została przyklejona kartka papieru w kratkę. Aby dokładnie zaznaczać kolejne maksymalne wychylenia wahadła, w odległości $d’&gt;1$m od wahadła zostało umieszczone źródło światła, zgodnie ze schematem.</p>
<p align="center">
<img src="/assets/images/2025-06-18/ukladpom.svg" width="500" />
</p>

<p>Cień rzucany przez linkę różnił się o $\Delta x’$ od prawdziwego jej położenia. Przy wymienionych wcześniej wartościach $d$ i $d’$, $\Delta x’&lt;0.02\Delta x$, zatem błąd jest pomijalny. Błąd związany z wyznaczeniem czasu również został pominięty, ponieważ dla tak małych wychyleń okres był w bardzo dobrym przybliżeniu stały i wahadło służyło jako zegar.</p>

<p>Co 5 okresów na kartce były zaznaczane maksymalne wychylenia wahadła. Następnie została zmierzona odległość linii, na której były zaznaczane kolejne położenia wahadła, od punktu zaczepienia wahadła ($h$), aby wyznaczyć $\tan{\theta}=\Delta x/h$. Ponieważ wychylenia były małe, $\theta\approx\tan{\theta}$. Wyniki pomiarów dla $l=0.8\text{m}$ zostały zestawione na poniższych wykresach.</p>
<p align="center">
<img src="/assets/images/2025-06-18/wykresbeta.svg" width="700" />
</p>

<p>W tym układzie otrzymana wartość $\beta$ to
$$	\beta = 0.01478\pm0.0002\frac{1}{\text{s}} $$
Tak mała niepewność wynika z kilku czynników. Niepewność w pomiarze kąta była bardzo niewielka, ponieważ źródło światła umożliwiało precyzyjne wyznaczenie wychylenia wahadła, a ze względu na dużą odległość $h$ zaznaczanych punktów od osi obrotu, niewielkie zmiany kąta powodowały dużą zmianę w odległości $\Delta x$. Niepewność w pomiarze czasu była pomijalna. Niepewność związana z wzięciem logarytmu naturalnego jest dana w przybliżeniu wzorem
$$	\Delta(\ln x)\approx\frac{\Delta x}{x}. $$
W tym przypadku $\Delta x$ było rzędu $10^{-3}$, a $x$ rzędu $10^{-1}$, czyli niepewność była rzędu $10^{-2}$.</p>

<p>Współczynniki tłumienia wyznaczone dla wielu wahadeł umieściłem na widocznym poniżej wykresie zależności $\beta(l)$. Okazało się, że w dobrym przybliżeniu punkty pomiarowe układają się na prostej o współczynniku kierunkowym $a=(0.0073\pm0.0019)\frac{1}{\text{sm}}$ i wyrazie wolnym $b=(0.0092\pm0.0012)\frac{1}{\text{s}}$. Jak wyjaśnić tę obserwację?</p>
<p align="center">
<img src="/assets/images/2025-06-18/wykresbetal.svg" width="700" />
</p>

<h2 id="wyjaśnienie-zaobserwowanej-zależności">Wyjaśnienie zaobserwowanej zależności</h2>
<p>Można spekulować, że wyraz wolny to część współczynnika tłumienia pochodząca od śruby służącej jako masa na końcu wahadła, a $al$ to wkład pochodzący od nitki.</p>

<p>Prawo Stokesa mówi, że wartość siły działającej na kulę o promieniu $R$ poruszającą się z małą prędkością $v$ w płynie jest dana wzorem
$$	F_o=6\pi\mu R v, $$
gdzie $\mu$ to lepkość dynamiczna. Nitkę można przybliżyć jako złożoną z $l/w$ kul o średnicy $w$, gdzie $w$ to również szerokość nitki, ułożonych jedna za drugą. Promień takiej kuli to wtedy $R=w/2$. Całkowita siła działająca na nitkę to suma sił pochodzących od jej wszystkich małych kul. Każda z nich ma jednak inną prędkość, ponieważ znajduje się w innej odległości od osi obrotu.
$$	F=\sum_{i=0}^{l/w}6\pi\mu\frac{w}{2}v_i=3\pi\mu w\omega\sum_{i=0}^{l/w} r_i, $$
gdzie $r_i$ to odległość $i$-tej kuli od osi obrotu. Aby obliczyć sumę, zapiszmy
$$	\sum_{i=0}^{l/w} r_i=\frac{1}{w}\sum_{i=0}^{l/w} r_i w. $$
Ponieważ $w$ jest małe w porównaniu do $l$, możemy aproksymować sumę jako całkę. Wtedy $w = \Delta r_i$, czyli
$$	\frac{1}{w}\sum_{i=0}^{l/w} r_i w\approx\frac{1}{w}\int_{0}^{l}r\,dr=\frac{l^2}{2w}.$$
Wstawiając ten wynik do wcześniejszego wzoru otrzymujemy
$$	F\approx \frac{3}{2}\pi\mu lv,$$
gdzie $v$ to prędkość końca wahadła. Ponieważ $F=2\beta m v$, zachodzi równość
$$
	\beta=\frac{3\pi\mu}{4m}l,
    $$
co wyjaśnia zaobserwowaną zależność.</p>

<h2 id="wyznaczanie-lepkości-dynamicznej-powietrza">Wyznaczanie lepkości dynamicznej powietrza</h2>
<p>Całkowita siła oporu działająca na wahadło to
$$	F=2\beta mv=2almv+2bmv,$$
gdzie m to masa śrubki zawieszonej na końcu wahadła (masa nitki jest pomijalna). Pierwszy wyraz po prawej stronie to siła pochodząca od nitki, czyli przyrównując to do wcześniej obliczonej siły otrzymujemy
$$		2almv=\frac{3}{2}\pi\mu lv $$
$$		4am=3\pi \mu $$
$$		\mu=\frac{4am}{3\pi}. $$
Zmierzona masa śrubki to $m=(4\pm 0.5)$g oraz $a=(0.0073\pm0.0019)\frac{1}{\text{ms}}$. Przy tych danych
	$$ \mu=(12.4\pm4.8)\times 10^{-6}\text{ Pa s},$$
przy czym tablicowa wartość $\mu$ dla powietrza w temperaturze $293\text{K}$ to $\mu=18.13\times 10^{-6}\text{ Pa s}$.</p>

<h2 id="wyznaczanie-gęstości-powietrza">Wyznaczanie gęstości powietrza</h2>
<p>Kinetyczna teoria gazów daje następujący wzór dla rozrzedzonych gazów:
$$	\mu=\alpha\rho\lambda\sqrt{\frac{2k_B T}{\pi m}},$$
gdzie bezwymiarowy współczynnik $\alpha\approx 1$, $\rho$ to gęstość gazu, $\lambda$ to średnia droga swobodna w tym gazie, $T$ to temperatura, a $m$ to masa cząsteczkowa. Przekształćmy ten wzór do postaci
$$	\rho=\frac{\mu}{\alpha\lambda}\sqrt{\frac{\pi m}{2k_B T}}.$$
Dla powietrza $m\approx29\text{u}\approx 4.28\times 10^{-26}\text{kg}$, $\lambda\approx6,6\times 10^{-8}$m. Temperatura podczas pomiarów wynosiła ok. $T\approx293\text{K}$. Wstawiając te dane do wzoru otrzymujemy wynik 
$$	\rho=(0.77\pm0.30)\frac{\text{kg}}{\text{m}^3},$$
przy czym tablicowa wartość w tej temperaturze to $\rho=1.20\frac{\text{kg}}{\text{m}^3}$. Wynik jest obarczony dużą niepewnością spowodowaną głównie niepewnością $m$ i $\mu$. Należy również zauważyć, że prawdziwa wartość $\rho$ nie mieści się w przedziale niepewności. Jest to najprawdopodobniej spowodowane przybliżeniem nitki jako złożonej z wielu kul.</p>]]></content><author><name></name></author><category term="Mechanika" /><summary type="html"><![CDATA[Tłumione wahadło matematyczne Rozważmy najprostszy model wahadła. Jest to masa punktowa $m$ zawieszona na nieważkiej lince o długości $l$. Na wahadło działa siła ciężkości $\mathbf{Q}$, która rozkłada się na składową radialną i styczną do linki oraz siła reakcji linki $\mathbf{F_r}$, która równoważy $\mathbf{Q_r}$. Na masę działa również siła oporu $\mathbf{F_o}$. Poniżej został przedstawiony schemat tego układu.]]></summary></entry></feed>